#!/usr/bin/env python3
"""
wm2: A window manager for the River Wayland compositor (v0.4+).

Implements the river-window-management-v1 and river-xkb-bindings-v1 protocols
to provide 4 desktops, a floating overlay stack, and 3 layout modes
(fullscreen, max, 2-split).

License: MIT
"""

import ctypes
import ctypes.util
import enum
import logging
import os
import select
import signal
import subprocess
import sys
import time
from dataclasses import dataclass, field
from typing import Optional

from pywayland.client import Display
from pywayland import ffi as _wl_ffi, lib as _wl_lib

# Protocol bindings (generated by pywayland scanner)
_script_dir = os.path.dirname(os.path.abspath(__file__))
if _script_dir not in sys.path:
    sys.path.insert(0, _script_dir)
from protocols.river_window_management_v1 import (
    RiverWindowManagerV1,
    RiverWindowV1,
    RiverOutputV1,
    RiverSeatV1,
    RiverNodeV1,
    RiverPointerBindingV1,
)
from protocols.river_xkb_bindings_v1 import (
    RiverXkbBindingsV1,
    RiverXkbBindingV1,
)
from protocols.river_xkb_config_v1 import (
    RiverXkbConfigV1,
    RiverXkbKeymapV1,
    RiverXkbKeyboardV1,
)
from protocols.river_layer_shell_v1 import (
    RiverLayerShellV1,
)
from protocols.wlr_layer_shell_unstable_v1 import (
    ZwlrLayerShellV1,
    ZwlrLayerSurfaceV1,
)
from protocols.wayland import (
    WlCompositor,
    WlShm,
    WlOutput,
)

logger = logging.getLogger("wm2")

# ---------------------------------------------------------------------------
# XKB keysym constants (from xkbcommon-keysyms.h)
# ---------------------------------------------------------------------------
XKB_KEY_1 = 0x0031
XKB_KEY_2 = 0x0032
XKB_KEY_3 = 0x0033
XKB_KEY_4 = 0x0034
XKB_KEY_q = 0x0071
XKB_KEY_w = 0x0077
XKB_KEY_e = 0x0065
XKB_KEY_r = 0x0072
XKB_KEY_f = 0x0066
XKB_KEY_m = 0x006d
XKB_KEY_s = 0x0073
XKB_KEY_j = 0x006a
XKB_KEY_k = 0x006b
XKB_KEY_l = 0x006c
XKB_KEY_h = 0x0068
XKB_KEY_n = 0x006e
XKB_KEY_p = 0x0070
XKB_KEY_o = 0x006f
XKB_KEY_c = 0x0063
XKB_KEY_d = 0x0064
XKB_KEY_g = 0x0067
XKB_KEY_t = 0x0074
XKB_KEY_Print = 0xFF61
XKB_KEY_Return = 0xFF0D
XKB_KEY_Tab = 0xFF09
XKB_KEY_space = 0x0020
XKB_KEY_comma = 0x002c
XKB_KEY_period = 0x002e

# Linux input event codes for pointer buttons
BTN_LEFT = 0x110
BTN_RIGHT = 0x111

# Modifier bitmask (from river_seat_v1.modifiers enum)
MOD_NONE = 0
MOD_SHIFT = 1
MOD_CTRL = 4
MOD_ALT = 8   # mod1
MOD_SUPER = 64  # mod4

# Window border edges bitmask
EDGE_NONE = 0
EDGE_TOP = 1
EDGE_BOTTOM = 2
EDGE_LEFT = 4
EDGE_RIGHT = 8
EDGE_ALL = EDGE_TOP | EDGE_BOTTOM | EDGE_LEFT | EDGE_RIGHT

# Border styling
BORDER_WIDTH = 2
_BORDER_FOCUSED = (0x52, 0x94, 0xE2, 0xFF)
_BORDER_UNFOCUSED = (0x40, 0x45, 0x52, 0xFF)


class LayoutMode(enum.Enum):
    FULLSCREEN = "fullscreen"
    MAX = "max"
    SPLIT = "split"


@dataclass
class ProcessConfig:
    """Configuration for a managed process."""
    cmd: str
    restart: bool = True
    restart_delay: float = 1.0
    restart_max_delay: float = 30.0


class Side(enum.Enum):
    LEFT = "left"
    RIGHT = "right"


# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------
@dataclass
class Config:
    """Runtime configuration with sensible defaults."""
    terminal_cmd: str = "foot"
    launcher_cmd: str = "fuzzel"
    border_width: int = BORDER_WIDTH
    default_layout: LayoutMode = LayoutMode.MAX
    bar_height: int = 0  # logical pixels reserved for top bar (auto-detected if 0)
    xkb_layout: str = ""    # [xkb] layout (e.g. "us"), empty = don't touch
    xkb_model: str = ""     # [xkb] model (e.g. "pc105"), empty = don't touch
    xkb_variant: str = ""   # [xkb] variant (e.g. "dvorak"), empty = don't touch
    xkb_options: str = ""   # [xkb] options (e.g. "ctrl:nocaps"), empty = don't touch
    wallpaper: str = ""     # path to wallpaper image, empty = no wallpaper
    processes: list = field(default_factory=list)  # list of ProcessConfig

    @classmethod
    def load(cls, path: Optional[str] = None) -> "Config":
        """Load config from a TOML file, falling back to defaults."""
        cfg = cls()
        if path is None:
            xdg = os.environ.get("XDG_CONFIG_HOME", os.path.expanduser("~/.config"))
            path = os.path.join(xdg, "wm2", "config.toml")
        if os.path.isfile(path):
            try:
                import tomllib
            except ImportError:
                try:
                    import tomli as tomllib
                except ImportError:
                    logger.warning("No TOML parser available; using defaults")
                    return cfg
            try:
                with open(path, "rb") as f:
                    data = tomllib.load(f)
                cfg.terminal_cmd = data.get("terminal", cfg.terminal_cmd)
                cfg.launcher_cmd = data.get("launcher", cfg.launcher_cmd)
                cfg.border_width = data.get("border_width", cfg.border_width)
                cfg.bar_height = data.get("bar_height", cfg.bar_height)
                xkb = data.get("xkb", {})
                cfg.xkb_layout = xkb.get("layout", cfg.xkb_layout)
                cfg.xkb_model = xkb.get("model", cfg.xkb_model)
                cfg.xkb_variant = xkb.get("variant", cfg.xkb_variant)
                cfg.xkb_options = xkb.get("options", cfg.xkb_options)
                cfg.wallpaper = data.get("wallpaper", cfg.wallpaper)
                if cfg.wallpaper:
                    cfg.wallpaper = os.path.expanduser(cfg.wallpaper)
                layout_str = data.get("default_layout", cfg.default_layout.value)
                cfg.default_layout = LayoutMode(layout_str)
                for proc in data.get("process", []):
                    cmd = proc.get("cmd")
                    if cmd:
                        cfg.processes.append(ProcessConfig(
                            cmd=cmd,
                            restart=proc.get("restart", True),
                            restart_delay=proc.get("restart_delay", 1.0),
                            restart_max_delay=proc.get("restart_max_delay", 30.0),
                        ))
                logger.info("Loaded config from %s", path)
            except Exception as e:
                logger.warning("Failed to load config from %s: %s", path, e)
        if cfg.bar_height == 0:
            cfg.bar_height = cls._detect_bar_height()
        return cfg

    @staticmethod
    def _detect_bar_height() -> int:
        """Auto-detect waybar height from its config and display scale."""
        import json, re
        bar_px = 0
        scale = 1.0
        # Read waybar config (jsonc)
        for path in [
            os.path.expanduser("~/.var/app/sh.ironforge.waybar/config/waybar/config"),
            os.path.expanduser("~/.config/waybar/config"),
        ]:
            try:
                with open(path) as f:
                    text = re.sub(r'//.*', '', f.read())  # strip jsonc comments
                    text = re.sub(r',\s*([}\]])', r'\1', text)  # strip trailing commas
                    data = json.loads(text)
                    bar_px = data.get("height", 0)
                    break
            except Exception:
                continue
        if bar_px == 0:
            return 0
        # Get display scale from wlr-randr
        try:
            out = subprocess.check_output(["wlr-randr"], stderr=subprocess.DEVNULL, text=True)
            for line in out.splitlines():
                if "Scale:" in line:
                    scale = float(line.split("Scale:")[1].strip())
                    break
        except Exception:
            pass
        height = int(bar_px / scale) if scale > 0 else bar_px
        logger.info("Auto-detected bar height: %dpx / scale %.1f = %d logical px", bar_px, scale, height)
        return height


# ---------------------------------------------------------------------------
# Process manager
# ---------------------------------------------------------------------------
class ProcessManager:
    """Manages child processes with SIGCHLD-driven restart and exponential backoff."""

    # Load wl_display_cancel_read from libwayland-client (not in pywayland CFFI)
    _libwayland = None

    @classmethod
    def _get_cancel_read(cls):
        if cls._libwayland is None:
            path = ctypes.util.find_library("wayland-client")
            cls._libwayland = ctypes.CDLL(path)
            fn = cls._libwayland.wl_display_cancel_read
            fn.argtypes = [ctypes.c_void_p]
            fn.restype = None
        return cls._libwayland.wl_display_cancel_read

    @dataclass
    class _ManagedProcess:
        config: ProcessConfig
        proc: Optional[subprocess.Popen] = None
        restart_count: int = 0
        last_start: float = 0.0
        next_restart_at: float = 0.0

    def __init__(self, configs):
        self._managed = [self._ManagedProcess(config=c) for c in configs]
        self._pipe_r = -1
        self._pipe_w = -1
        self._old_wakeup_fd = -1

    def setup_sigchld_pipe(self):
        """Create a self-pipe and set it as the SIGCHLD wakeup fd."""
        self._pipe_r, self._pipe_w = os.pipe2(os.O_NONBLOCK | os.O_CLOEXEC)
        self._old_wakeup_fd = signal.set_wakeup_fd(self._pipe_w, warn_on_full_buffer=False)
        signal.signal(signal.SIGCHLD, lambda signum, frame: None)  # need a handler for set_wakeup_fd

    @property
    def pipe_fd(self):
        return self._pipe_r

    def start_all(self):
        """Spawn all configured processes."""
        for mp in self._managed:
            self._start(mp)

    def _start(self, mp):
        try:
            mp.proc = subprocess.Popen(
                mp.config.cmd, shell=True,
                stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                start_new_session=True,
            )
            mp.last_start = time.monotonic()
            logger.info("Started managed process: %s (pid=%d)", mp.config.cmd, mp.proc.pid)
        except Exception as e:
            logger.error("Failed to start managed process %s: %s", mp.config.cmd, e)

    def handle_sigchld(self):
        """Drain the self-pipe and reap children. Schedule restarts as needed."""
        # Drain pipe
        while True:
            try:
                os.read(self._pipe_r, 4096)
            except BlockingIOError:
                break

        # Reap all finished children
        while True:
            try:
                pid, status = os.waitpid(-1, os.WNOHANG)
            except ChildProcessError:
                break
            if pid == 0:
                break
            # Find the managed process for this pid
            for mp in self._managed:
                if mp.proc is not None and mp.proc.pid == pid:
                    mp.proc.returncode = os.waitstatus_to_exitcode(status)
                    logger.info("Managed process exited: %s (pid=%d, rc=%d)",
                                mp.config.cmd, pid, mp.proc.returncode)
                    mp.proc = None
                    if mp.config.restart:
                        # Exponential backoff: delay * 2^count, capped at max_delay
                        uptime = time.monotonic() - mp.last_start
                        if uptime > 60.0:
                            mp.restart_count = 0  # reset after stable run
                        delay = min(
                            mp.config.restart_delay * (2 ** mp.restart_count),
                            mp.config.restart_max_delay,
                        )
                        mp.restart_count += 1
                        mp.next_restart_at = time.monotonic() + delay
                        logger.info("Will restart %s in %.1fs (attempt %d)",
                                    mp.config.cmd, delay, mp.restart_count)
                    break

    def process_restarts(self):
        """Start any processes due for restart. Return seconds until next, or None."""
        now = time.monotonic()
        next_at = None
        for mp in self._managed:
            if mp.proc is None and mp.config.restart and mp.next_restart_at > 0:
                if now >= mp.next_restart_at:
                    mp.next_restart_at = 0.0
                    self._start(mp)
                else:
                    t = mp.next_restart_at - now
                    if next_at is None or t < next_at:
                        next_at = t
        return next_at

    def terminate_all(self):
        """SIGTERM all managed process groups, wait, then SIGKILL stragglers."""
        for mp in self._managed:
            if mp.proc is not None:
                try:
                    os.killpg(mp.proc.pid, signal.SIGTERM)
                except OSError:
                    pass

        deadline = time.monotonic() + 3.0
        while time.monotonic() < deadline:
            alive = [mp for mp in self._managed if mp.proc is not None]
            if not alive:
                break
            for mp in alive:
                try:
                    pid, _ = os.waitpid(mp.proc.pid, os.WNOHANG)
                    if pid != 0:
                        mp.proc = None
                except ChildProcessError:
                    mp.proc = None
            time.sleep(0.05)

        # SIGKILL stragglers
        for mp in self._managed:
            if mp.proc is not None:
                try:
                    os.killpg(mp.proc.pid, signal.SIGKILL)
                except OSError:
                    pass
                try:
                    os.waitpid(mp.proc.pid, 0)
                except ChildProcessError:
                    pass
                mp.proc = None

    def close_pipe(self):
        """Restore the old wakeup fd and close the pipe."""
        if self._pipe_w >= 0:
            try:
                signal.set_wakeup_fd(self._old_wakeup_fd)
            except Exception:
                pass
            os.close(self._pipe_w)
            self._pipe_w = -1
        if self._pipe_r >= 0:
            os.close(self._pipe_r)
            self._pipe_r = -1


# ---------------------------------------------------------------------------
# Window wrapper
# ---------------------------------------------------------------------------
@dataclass
class WindowState:
    """Tracks state for a single window managed by the WM."""
    proxy: object  # RiverWindowV1 proxy
    node: object = None  # RiverNodeV1 proxy
    app_id: Optional[str] = None
    title: Optional[str] = None
    width: int = 0
    height: int = 0
    parent: Optional["WindowState"] = None
    desktop_id: int = 1  # 1-4 or 0 for floating overlay
    side: Side = Side.LEFT  # only meaningful in split mode
    is_fullscreen: bool = False
    pending_initial_dimensions: bool = True
    closed: bool = False
    # For interactive move/resize
    move_start_x: int = 0
    move_start_y: int = 0
    pos_x: int = 0
    pos_y: int = 0


# ---------------------------------------------------------------------------
# Desktop
# ---------------------------------------------------------------------------
@dataclass
class Desktop:
    """Represents one of the 4 desktops."""
    id: int
    layout: LayoutMode = LayoutMode.MAX
    windows: list = field(default_factory=list)  # ordered stack, [0] = top
    focused_index: int = 0
    # 2-split mode state
    left_stack: list = field(default_factory=list)   # ordered, [0] = top
    right_stack: list = field(default_factory=list)
    focused_side: Side = Side.LEFT

    def all_windows(self) -> list:
        """Return all windows on this desktop."""
        if self.layout == LayoutMode.SPLIT:
            return self.left_stack + self.right_stack
        return list(self.windows)

    def add_window(self, win: WindowState):
        """Add a window to the top of the appropriate stack."""
        if self.layout == LayoutMode.SPLIT:
            # Auto-balance: if focused side has windows and other side is empty,
            # place on the empty side for natural split distribution
            left_has = len(self.left_stack) > 0
            right_has = len(self.right_stack) > 0
            if self.focused_side == Side.LEFT and left_has and not right_has:
                self.right_stack.insert(0, win)
                win.side = Side.RIGHT
                self.focused_side = Side.RIGHT
            elif self.focused_side == Side.RIGHT and right_has and not left_has:
                self.left_stack.insert(0, win)
                win.side = Side.LEFT
                self.focused_side = Side.LEFT
            elif self.focused_side == Side.LEFT:
                self.left_stack.insert(0, win)
                win.side = Side.LEFT
            else:
                self.right_stack.insert(0, win)
                win.side = Side.RIGHT
        else:
            self.windows.insert(0, win)
            self.focused_index = 0

    def remove_window(self, win: WindowState):
        """Remove a window from whatever stack it's in."""
        if win in self.windows:
            self.windows.remove(win)
            if self.focused_index >= len(self.windows) and self.windows:
                self.focused_index = len(self.windows) - 1
        if win in self.left_stack:
            self.left_stack.remove(win)
        if win in self.right_stack:
            self.right_stack.remove(win)

    def get_focused_window(self) -> Optional[WindowState]:
        """Return the currently focused window on this desktop."""
        if self.layout == LayoutMode.SPLIT:
            stack = self.left_stack if self.focused_side == Side.LEFT else self.right_stack
            return stack[0] if stack else None
        if self.windows:
            idx = max(0, min(self.focused_index, len(self.windows) - 1))
            return self.windows[idx]
        return None

    def ensure_window_in_split_stacks(self, win: WindowState):
        """Ensure a window is in the correct split stack based on its side."""
        if win in self.left_stack:
            self.left_stack.remove(win)
        if win in self.right_stack:
            self.right_stack.remove(win)
        if win.side == Side.LEFT:
            self.left_stack.insert(0, win)
        else:
            self.right_stack.insert(0, win)

    def migrate_to_split(self):
        """When switching to split mode, distribute windows to left/right."""
        all_wins = list(self.windows)
        self.left_stack.clear()
        self.right_stack.clear()

        has_left = any(w.side == Side.LEFT for w in all_wins)
        has_right = any(w.side == Side.RIGHT for w in all_wins)

        if has_left and has_right:
            for w in all_wins:
                if w.side == Side.LEFT:
                    self.left_stack.append(w)
                else:
                    self.right_stack.append(w)
        else:
            for i, w in enumerate(all_wins):
                if i % 2 == 0:
                    self.left_stack.append(w)
                    w.side = Side.LEFT
                else:
                    self.right_stack.append(w)
                    w.side = Side.RIGHT
            self.focused_side = Side.LEFT

    def migrate_from_split(self):
        """When switching from split mode, merge stacks into windows list."""
        if self.focused_side == Side.RIGHT:
            self.windows = list(self.right_stack) + list(self.left_stack)
        else:
            self.windows = list(self.left_stack) + list(self.right_stack)
        self.focused_index = 0


# ---------------------------------------------------------------------------
# Output wrapper
# ---------------------------------------------------------------------------
@dataclass
class OutputState:
    """Tracks state for a logical output (monitor)."""
    proxy: object  # RiverOutputV1 proxy
    x: int = 0
    y: int = 0
    width: int = 0
    height: int = 0
    removed: bool = False
    # Non-exclusive area from layer shell (usable area after bars etc.)
    nea_x: Optional[int] = None
    nea_y: Optional[int] = None
    nea_w: Optional[int] = None
    nea_h: Optional[int] = None
    layer_shell_output: object = None  # RiverLayerShellOutputV1 proxy
    wl_output: object = None           # WlOutput proxy (for layer shell)
    scale: int = 1                     # wl_output scale factor
    bg_surface: object = None          # WlSurface for wallpaper
    bg_layer_surface: object = None    # ZwlrLayerSurfaceV1


# ---------------------------------------------------------------------------
# Seat wrapper
# ---------------------------------------------------------------------------
@dataclass
class SeatState:
    """Tracks state for an input seat."""
    proxy: object  # RiverSeatV1 proxy
    pointer_x: int = 0
    pointer_y: int = 0
    pointer_entered_window: Optional[WindowState] = None
    op_active: bool = False
    op_dx: int = 0
    op_dy: int = 0
    op_released: bool = False
    op_window: Optional[WindowState] = None
    op_mode: str = ""  # "move" or "resize"


# ---------------------------------------------------------------------------
# Main Window Manager
# ---------------------------------------------------------------------------
class RiverWM:
    """
    The main window manager implementing the river-window-management-v1
    protocol for the River Wayland compositor.
    """

    def __init__(self, config: Config):
        self.config = config
        self.display: Optional[Display] = None
        self.registry = None

        # Protocol globals
        self.wm_proxy = None  # RiverWindowManagerV1 proxy
        self.xkb_bindings_proxy = None  # RiverXkbBindingsV1 proxy
        self.layer_shell_proxy = None  # RiverLayerShellV1 proxy
        self.xkb_config_proxy = None   # RiverXkbConfigV1 proxy
        self.xkb_keymap_obj = None     # RiverXkbKeymapV1 (after success)
        self.xkb_keyboards: list = []  # RiverXkbKeyboardV1 objects

        # Wallpaper globals
        self.compositor_proxy = None   # WlCompositor proxy
        self.shm_proxy = None          # WlShm proxy
        self.layer_shell_bg_proxy = None  # ZwlrLayerShellV1 proxy
        self._wl_outputs: dict = {}    # global name -> WlOutput proxy

        # State
        self.windows: dict = {}  # proxy id -> WindowState
        self.outputs: list = []  # list of OutputState
        self.seats: list = []    # list of SeatState
        self.desktops: dict = {i: Desktop(id=i, layout=config.default_layout) for i in range(1, 5)}
        self.floating_stack: list = []  # WindowState list, [0] = top

        self.current_desktop_id: int = 1
        self.floating_active: bool = False

        # Protocol sequence state
        self.in_manage: bool = False
        self.in_render: bool = False
        self.needs_layout: bool = True
        self.pending_new_windows: list = []
        self.pending_bindings_to_enable: list = []

        # Keybinding registry
        self.key_bindings: dict = {}  # binding_proxy -> callback
        self.pointer_bindings: dict = {}  # binding_proxy -> (callback_press, callback_release)

        # Interactive operation tracking
        self.active_op_seat: Optional[SeatState] = None

        # Process management
        self.process_manager: Optional[ProcessManager] = None

        self.running = True

    @property
    def current_desktop(self) -> Desktop:
        return self.desktops[self.current_desktop_id]

    @property
    def primary_output(self) -> Optional[OutputState]:
        for o in self.outputs:
            if not o.removed:
                return o
        return None

    def _usable_area(self, output: OutputState):
        """Return (x, y, w, h) of the usable area for windows on this output."""
        if output.nea_x is not None:
            return output.nea_x, output.nea_y, output.nea_w, output.nea_h
        bar_h = self.config.bar_height
        return output.x, output.y + bar_h, output.width, output.height - bar_h

    # -------------------------------------------------------------------
    # Connection & registry
    # -------------------------------------------------------------------
    def connect(self):
        """Connect to the Wayland display and bind protocol globals."""
        self.display = Display()
        self.display.connect()
        logger.info("Connected to Wayland display")

        self.registry = self.display.get_registry()
        self.registry.dispatcher["global"] = self._on_global
        self.display.roundtrip()

        if self.wm_proxy is None:
            logger.error("river_window_manager_v1 global not found. Is River running?")
            sys.exit(1)
        if self.xkb_bindings_proxy is None:
            logger.error("river_xkb_bindings_v1 global not found.")
            sys.exit(1)

        logger.info("Bound protocol globals successfully")

    def _on_global(self, registry, id_num, iface_name, version):
        """Handle wl_registry.global events to bind our protocol interfaces."""
        if iface_name == "river_window_manager_v1":
            self.wm_proxy = registry.bind(id_num, RiverWindowManagerV1, min(version, 3))
            self._setup_wm_events()
        elif iface_name == "river_xkb_bindings_v1":
            self.xkb_bindings_proxy = registry.bind(id_num, RiverXkbBindingsV1, min(version, 2))
        elif iface_name == "river_xkb_config_v1":
            self.xkb_config_proxy = registry.bind(id_num, RiverXkbConfigV1, min(version, 1))
            self.xkb_config_proxy.dispatcher["xkb_keyboard"] = self._on_xkb_keyboard
            logger.info("Bound river_xkb_config_v1 — runtime keymap control enabled")
        elif iface_name == "river_layer_shell_v1":
            self.layer_shell_proxy = registry.bind(id_num, RiverLayerShellV1, min(version, 1))
            logger.info("Bound river_layer_shell_v1 — layer surfaces enabled")
        elif iface_name == "wl_compositor":
            self.compositor_proxy = registry.bind(id_num, WlCompositor, min(version, 4))
        elif iface_name == "wl_shm":
            self.shm_proxy = registry.bind(id_num, WlShm, min(version, 1))
        elif iface_name == "wl_output":
            wl_out = registry.bind(id_num, WlOutput, min(version, 4))
            wl_out.dispatcher["scale"] = self._on_wl_output_scale
            self._wl_outputs[id_num] = wl_out
        elif iface_name == "zwlr_layer_shell_v1":
            self.layer_shell_bg_proxy = registry.bind(id_num, ZwlrLayerShellV1, min(version, 4))
            logger.info("Bound zwlr_layer_shell_v1 — wallpaper layer shell enabled")

    # -------------------------------------------------------------------
    # WM event handlers
    # -------------------------------------------------------------------
    def _setup_wm_events(self):
        """Register event handlers on the window manager proxy."""
        self.wm_proxy.dispatcher["unavailable"] = self._on_unavailable
        self.wm_proxy.dispatcher["finished"] = self._on_finished
        self.wm_proxy.dispatcher["manage_start"] = self._on_manage_start
        self.wm_proxy.dispatcher["render_start"] = self._on_render_start
        self.wm_proxy.dispatcher["window"] = self._on_window
        self.wm_proxy.dispatcher["output"] = self._on_output
        self.wm_proxy.dispatcher["seat"] = self._on_seat
        self.wm_proxy.dispatcher["session_locked"] = self._on_session_locked
        self.wm_proxy.dispatcher["session_unlocked"] = self._on_session_unlocked

    def _on_unavailable(self, proxy):
        logger.error("Window management unavailable (another WM running?)")
        self.running = False

    def _on_finished(self, proxy):
        logger.info("Server finished with window manager")
        self.running = False

    def _on_session_locked(self, proxy):
        logger.info("Session locked")

    def _on_session_unlocked(self, proxy):
        logger.info("Session unlocked")

    # -------------------------------------------------------------------
    # Window events
    # -------------------------------------------------------------------
    def _on_window(self, wm_proxy, window_proxy):
        """A new window has been created."""
        win = WindowState(proxy=window_proxy)
        self.windows[id(window_proxy)] = win

        # Get the render node for this window
        node_proxy = window_proxy.get_node()
        win.node = node_proxy

        # Register window event handlers
        window_proxy.dispatcher["closed"] = lambda p: self._on_window_closed(win)
        window_proxy.dispatcher["dimensions"] = lambda p, w, h: self._on_window_dimensions(win, w, h)
        window_proxy.dispatcher["app_id"] = lambda p, aid: setattr(win, 'app_id', aid)
        window_proxy.dispatcher["title"] = lambda p, t: setattr(win, 'title', t)
        window_proxy.dispatcher["parent"] = lambda p, pp: setattr(win, 'parent', self.windows.get(id(pp)) if pp else None)
        window_proxy.dispatcher["decoration_hint"] = lambda p, hint: None  # ignore
        window_proxy.dispatcher["pointer_move_requested"] = lambda p, seat: self._on_pointer_move_requested(win, seat)
        window_proxy.dispatcher["pointer_resize_requested"] = lambda p, seat, edges: self._on_pointer_resize_requested(win, seat, edges)
        self.pending_new_windows.append(win)
        logger.info("New window created: %s", id(window_proxy))

    def _on_window_closed(self, win: WindowState):
        """Window has been closed by the server."""
        win.closed = True
        logger.info("Window closed: app_id=%s title=%s", win.app_id, win.title)

    def _on_window_dimensions(self, win: WindowState, width: int, height: int):
        """Window dimensions event (render sequence)."""
        changed = (win.width != width or win.height != height)
        win.width = width
        win.height = height
        win.pending_initial_dimensions = False
        if changed:
            self.needs_layout = True
            # Re-assert tiled layout dimensions if a window changed size on its own
            # (e.g. font size change, CSD resize attempt). This triggers a manage
            # sequence that will re-propose the correct split/max dimensions.
            self.wm_proxy.manage_dirty()

    def _on_pointer_move_requested(self, win: WindowState, seat_proxy):
        """Window requested interactive pointer move."""
        seat = self._find_seat(seat_proxy)
        if seat and self.in_manage and win.desktop_id == 0:
            self._start_interactive_op(seat, win, "move")

    def _on_pointer_resize_requested(self, win: WindowState, seat_proxy, edges):
        """Window requested interactive pointer resize."""
        seat = self._find_seat(seat_proxy)
        if seat and self.in_manage and win.desktop_id == 0:
            self._start_interactive_op(seat, win, "resize")

    # -------------------------------------------------------------------
    # Output events
    # -------------------------------------------------------------------
    def _on_output(self, wm_proxy, output_proxy):
        """A new output has been created."""
        out = OutputState(proxy=output_proxy)
        self.outputs.append(out)

        output_proxy.dispatcher["removed"] = lambda p: self._on_output_removed(out)
        output_proxy.dispatcher["position"] = lambda p, x, y: self._on_output_position(out, x, y)
        output_proxy.dispatcher["dimensions"] = lambda p, w, h: self._on_output_dimensions(out, w, h)
        output_proxy.dispatcher["wl_output"] = lambda p, name: self._on_output_wl_output(out, name)

        # Bind layer shell output for non_exclusive_area events
        if self.layer_shell_proxy is not None:
            ls_out = self.layer_shell_proxy.get_output(output_proxy)
            out.layer_shell_output = ls_out
            ls_out.dispatcher["non_exclusive_area"] = (
                lambda p, x, y, w, h: self._on_non_exclusive_area(out, x, y, w, h)
            )
            ls_out.set_default()

        logger.info("New output created")

    def _on_output_removed(self, out: OutputState):
        out.removed = True
        if out.bg_layer_surface is not None:
            out.bg_layer_surface.destroy()
            out.bg_layer_surface = None
        if out.bg_surface is not None:
            out.bg_surface.destroy()
            out.bg_surface = None
        logger.info("Output removed")

    def _on_output_wl_output(self, out: OutputState, name: int):
        wl_out = self._wl_outputs.get(name)
        if wl_out is not None:
            out.wl_output = wl_out

    def _on_wl_output_scale(self, proxy, factor):
        """Handle wl_output scale event — find matching OutputState and re-render wallpaper."""
        for out in self.outputs:
            if out.wl_output is proxy:
                if out.scale != factor:
                    out.scale = factor
                    logger.info("Output scale changed to %d", factor)
                    self._recreate_wallpaper(out)
                break

    def _on_output_position(self, out: OutputState, x: int, y: int):
        out.x = x
        out.y = y
        self.needs_layout = True

    def _on_output_dimensions(self, out: OutputState, width: int, height: int):
        out.width = width
        out.height = height
        self.needs_layout = True
        logger.info("Output dimensions: %dx%d at (%d,%d)", width, height, out.x, out.y)
        self._recreate_wallpaper(out)

    def _on_non_exclusive_area(self, out: OutputState, x: int, y: int, w: int, h: int):
        out.nea_x = x
        out.nea_y = y
        out.nea_w = w
        out.nea_h = h
        self.needs_layout = True
        logger.info("Non-exclusive area: %d,%d %dx%d", x, y, w, h)

    # -------------------------------------------------------------------
    # Wallpaper rendering
    # -------------------------------------------------------------------
    def _recreate_wallpaper(self, out: OutputState):
        """Tear down and recreate wallpaper for an output (handles scale/resize)."""
        if out.bg_layer_surface is not None:
            out.bg_layer_surface.destroy()
            out.bg_layer_surface = None
        if out.bg_surface is not None:
            out.bg_surface.destroy()
            out.bg_surface = None
        if out.width > 0 and out.height > 0:
            self._setup_wallpaper(out)

    def _setup_wallpaper(self, out: OutputState):
        """Create a layer surface background wallpaper for an output."""
        if not self.config.wallpaper:
            return
        if self.layer_shell_bg_proxy is None or self.compositor_proxy is None or self.shm_proxy is None:
            return
        if out.wl_output is None:
            return

        try:
            from PIL import Image
        except ImportError:
            logger.warning("Pillow not installed; wallpaper disabled")
            return

        wallpaper_path = self.config.wallpaper
        if not os.path.isfile(wallpaper_path):
            logger.warning("Wallpaper file not found: %s", wallpaper_path)
            return

        # Render at physical pixel resolution
        buf_scale = out.scale
        phys_w = out.width * buf_scale
        phys_h = out.height * buf_scale

        try:
            img = Image.open(wallpaper_path).convert("RGBA")
        except Exception as e:
            logger.error("Failed to open wallpaper %s: %s", wallpaper_path, e)
            return

        # Fill mode: scale preserving aspect ratio, center-crop to physical size
        src_w, src_h = img.size
        img_scale = max(phys_w / src_w, phys_h / src_h)
        new_w = int(src_w * img_scale)
        new_h = int(src_h * img_scale)
        img = img.resize((new_w, new_h), Image.LANCZOS)
        left = (new_w - phys_w) // 2
        top = (new_h - phys_h) // 2
        img = img.crop((left, top, left + phys_w, top + phys_h))

        pixel_data = img.tobytes("raw", "BGRA")
        del img  # free original, only keep pixel_data

        # Create wl_surface
        surface = self.compositor_proxy.create_surface()
        surface.set_buffer_scale(buf_scale)
        out.bg_surface = surface

        # Create layer surface on background layer
        LAYER_BACKGROUND = ZwlrLayerShellV1.layer.background
        layer_surface = self.layer_shell_bg_proxy.get_layer_surface(
            surface, out.wl_output, LAYER_BACKGROUND, "wallpaper"
        )
        out.bg_layer_surface = layer_surface

        # Anchor all edges, auto-fill size, exclusive zone -1
        ANCHOR_ALL = (ZwlrLayerSurfaceV1.anchor.top |
                      ZwlrLayerSurfaceV1.anchor.bottom |
                      ZwlrLayerSurfaceV1.anchor.left |
                      ZwlrLayerSurfaceV1.anchor.right)
        layer_surface.set_anchor(ANCHOR_ALL)
        layer_surface.set_size(0, 0)
        layer_surface.set_exclusive_zone(-1)

        def _on_configure(proxy, serial, conf_w, conf_h):
            layer_surface.ack_configure(serial)
            stride = phys_w * 4
            size = stride * phys_h
            fd = os.memfd_create("wm2-wallpaper")
            os.ftruncate(fd, size)
            os.lseek(fd, 0, os.SEEK_SET)
            os.write(fd, pixel_data[:size])
            pool = self.shm_proxy.create_pool(fd, size)
            buf = pool.create_buffer(0, phys_w, phys_h, stride, WlShm.format.argb8888)
            os.close(fd)
            surface.attach(buf, 0, 0)
            surface.damage(0, 0, out.width, out.height)
            surface.commit()
            pool.destroy()
            logger.info("Wallpaper rendered %dx%d (scale %d)", phys_w, phys_h, buf_scale)

        def _on_closed(proxy):
            logger.info("Wallpaper layer surface closed")
            out.bg_layer_surface = None
            out.bg_surface = None

        layer_surface.dispatcher["configure"] = _on_configure
        layer_surface.dispatcher["closed"] = _on_closed

        # Initial commit to trigger configure
        surface.commit()
        logger.info("Wallpaper layer surface created for output %dx%d (scale %d)", out.width, out.height, buf_scale)

    # -------------------------------------------------------------------
    # Seat events
    # -------------------------------------------------------------------
    def _on_seat(self, wm_proxy, seat_proxy):
        """A new seat has been created."""
        seat = SeatState(proxy=seat_proxy)
        self.seats.append(seat)

        seat_proxy.dispatcher["removed"] = lambda p: self._on_seat_removed(seat)
        seat_proxy.dispatcher["pointer_enter"] = lambda p, win: self._on_pointer_enter(seat, win)
        seat_proxy.dispatcher["pointer_leave"] = lambda p: self._on_pointer_leave(seat)
        seat_proxy.dispatcher["window_interaction"] = lambda p, win: self._on_window_interaction(seat, win)
        seat_proxy.dispatcher["op_delta"] = lambda p, dx, dy: self._on_op_delta(seat, dx, dy)
        seat_proxy.dispatcher["op_release"] = lambda p: self._on_op_release(seat)
        seat_proxy.dispatcher["pointer_position"] = lambda p, x, y: self._on_pointer_position(seat, x, y)

        logger.info("New seat created")

    def _on_seat_removed(self, seat: SeatState):
        if seat in self.seats:
            self.seats.remove(seat)
        logger.info("Seat removed")

    def _on_pointer_enter(self, seat: SeatState, window_proxy):
        win = self.windows.get(id(window_proxy))
        seat.pointer_entered_window = win

    def _on_pointer_leave(self, seat: SeatState):
        seat.pointer_entered_window = None

    def _on_window_interaction(self, seat: SeatState, window_proxy):
        """User interacted with a window — focus it."""
        win = self.windows.get(id(window_proxy))
        if win and not win.closed:
            self._focus_window(seat, win)

    def _on_pointer_position(self, seat: SeatState, x: int, y: int):
        seat.pointer_x = x
        seat.pointer_y = y

    def _on_op_delta(self, seat: SeatState, dx: int, dy: int):
        seat.op_dx = dx
        seat.op_dy = dy

    def _on_op_release(self, seat: SeatState):
        seat.op_released = True

    # -------------------------------------------------------------------
    # Manage / Render sequence handling
    # -------------------------------------------------------------------
    def _on_manage_start(self, proxy):
        """Handle manage_start event — apply window management state changes."""
        logger.debug(">>> manage_start (windows=%d)", len(self.windows))
        self.in_manage = True
        self.in_render = False

        # Process closed windows
        closed = [w for w in self.windows.values() if w.closed]
        for win in closed:
            logger.info("Removing closed window: %s (proxy=%s)", win.app_id, id(win.proxy))
            self._remove_window(win)
            win.proxy.destroy()
            del self.windows[id(win.proxy)]
            logger.info("Window removed successfully")

        # Place new windows
        for win in self.pending_new_windows:
            if not win.closed:
                self._place_new_window(win)
        self.pending_new_windows.clear()

        # Enable pending bindings
        for binding in self.pending_bindings_to_enable:
            binding.enable()
        self.pending_bindings_to_enable.clear()

        # Handle interactive operations
        for seat in self.seats:
            if seat.op_active and seat.op_window:
                self._handle_interactive_op(seat)

        # Apply window management state (focus, fullscreen, dimensions)
        self._apply_manage_state()

        # Finish manage sequence
        self.wm_proxy.manage_finish()
        self.in_manage = False
        logger.debug("<<< manage_finish")

    def _on_render_start(self, proxy):
        """Handle render_start event — apply rendering state changes."""
        logger.debug(">>> render_start")
        self.in_render = True
        self.in_manage = False

        # Apply layout (positions, visibility, z-order, borders)
        self._apply_render_state()

        # Finish render sequence
        self.wm_proxy.render_finish()
        self.in_render = False
        logger.debug("<<< render_finish")

    # -------------------------------------------------------------------
    # Window placement
    # -------------------------------------------------------------------
    def _place_new_window(self, win: WindowState):
        """Place a newly created window on the appropriate desktop/stack."""
        output = self.primary_output
        if output is None:
            return

        if self.floating_active:
            # Place in floating overlay
            win.desktop_id = 0
            self.floating_stack.insert(0, win)
            # Center on output
            win.pos_x = output.x + output.width // 4
            win.pos_y = output.y + output.height // 4
            logger.info("Placed window in floating overlay")
        else:
            desktop = self.current_desktop
            win.desktop_id = self.current_desktop_id
            desktop.add_window(win)
            logger.info("Placed window on desktop %d", self.current_desktop_id)

        # Propose initial dimensions
        self._propose_window_dimensions(win)

    def _propose_window_dimensions(self, win: WindowState):
        """Propose dimensions for a window based on its context."""
        output = self.primary_output
        if output is None:
            return

        if win.desktop_id == 0:
            # Floating: half output size
            w = output.width // 2
            h = output.height // 2
            win.proxy.set_tiled(EDGE_NONE)
            win.proxy.propose_dimensions(w, h)
            return

        desktop = self.desktops[win.desktop_id]

        if desktop.layout == LayoutMode.FULLSCREEN:
            # Fullscreen: compositor handles dimensions
            win.proxy.propose_dimensions(output.width, output.height)
        elif desktop.layout == LayoutMode.MAX:
            win.proxy.propose_dimensions(output.width, output.height)
        elif desktop.layout == LayoutMode.SPLIT:
            ua_x, ua_y, ua_w, ua_h = self._usable_area(output)
            win.proxy.propose_dimensions(ua_w // 2, ua_h)

    def _remove_window(self, win: WindowState):
        """Remove a window from all tracking structures."""
        if win.desktop_id == 0:
            if win in self.floating_stack:
                self.floating_stack.remove(win)
        else:
            desktop = self.desktops.get(win.desktop_id)
            if desktop:
                desktop.remove_window(win)

    # -------------------------------------------------------------------
    # Focus management
    # -------------------------------------------------------------------
    def _focus_window(self, seat: SeatState, win: WindowState):
        """Set focus to a specific window."""
        if win is None or win.closed:
            return

        # If the window is on a different desktop, switch to it
        if win.desktop_id != 0 and win.desktop_id != self.current_desktop_id:
            self._switch_desktop(win.desktop_id)
        elif win.desktop_id == 0 and not self.floating_active:
            self.floating_active = True

        # Update desktop focus tracking
        if win.desktop_id == 0:
            if win in self.floating_stack:
                self.floating_stack.remove(win)
                self.floating_stack.insert(0, win)
        else:
            desktop = self.desktops[win.desktop_id]
            if desktop.layout == LayoutMode.SPLIT:
                if win in desktop.left_stack:
                    desktop.focused_side = Side.LEFT
                    idx = desktop.left_stack.index(win)
                    if idx > 0:
                        desktop.left_stack.remove(win)
                        desktop.left_stack.insert(0, win)
                elif win in desktop.right_stack:
                    desktop.focused_side = Side.RIGHT
                    idx = desktop.right_stack.index(win)
                    if idx > 0:
                        desktop.right_stack.remove(win)
                        desktop.right_stack.insert(0, win)
            else:
                if win in desktop.windows:
                    desktop.focused_index = desktop.windows.index(win)

        if self.in_manage:
            seat.proxy.focus_window(win.proxy)

    def _get_focused_window(self) -> Optional[WindowState]:
        """Get the currently focused window."""
        if self.floating_active and self.floating_stack:
            return self.floating_stack[0]
        return self.current_desktop.get_focused_window()

    # -------------------------------------------------------------------
    # Desktop switching
    # -------------------------------------------------------------------
    def _switch_desktop(self, desktop_id: int):
        """Switch to a different desktop."""
        if desktop_id < 1 or desktop_id > 4:
            return
        self.floating_active = False
        self.current_desktop_id = desktop_id
        self.needs_layout = True
        logger.info("Switched to desktop %d", desktop_id)

    def _move_window_to_desktop(self, win: WindowState, target_desktop_id: int):
        """Move a window to a different desktop."""
        if win is None or win.closed:
            return
        if target_desktop_id < 0 or target_desktop_id > 4:
            return

        # Remove from current location
        self._remove_window(win)

        if target_desktop_id == 0:
            # Move to floating overlay
            win.desktop_id = 0
            output = self.primary_output
            if output:
                win.pos_x = output.x + output.width // 4
                win.pos_y = output.y + output.height // 4
            self.floating_stack.insert(0, win)
        else:
            win.desktop_id = target_desktop_id
            target = self.desktops[target_desktop_id]
            if target.layout == LayoutMode.SPLIT:
                target.ensure_window_in_split_stacks(win)
            else:
                target.add_window(win)

        self.needs_layout = True

    # -------------------------------------------------------------------
    # Layout mode switching
    # -------------------------------------------------------------------
    def _set_layout_mode(self, mode: LayoutMode):
        """Switch the current desktop's layout mode."""
        desktop = self.current_desktop
        old_mode = desktop.layout

        if old_mode == mode:
            return

        # Handle fullscreen exit
        if old_mode == LayoutMode.FULLSCREEN:
            for win in desktop.windows:
                if win.is_fullscreen:
                    win.proxy.exit_fullscreen()
                    win.proxy.inform_not_fullscreen()
                    win.is_fullscreen = False

        # Migrate window stacks
        if old_mode == LayoutMode.SPLIT and mode != LayoutMode.SPLIT:
            desktop.migrate_from_split()
        elif old_mode != LayoutMode.SPLIT and mode == LayoutMode.SPLIT:
            desktop.migrate_to_split()

        desktop.layout = mode
        self.needs_layout = True
        # NOTE: Do NOT call propose_dimensions here — it is a manage-sequence-only
        # request.  _apply_manage_state will propose correct dimensions when the
        # next manage sequence runs (triggered by manage_dirty in the caller).

        logger.info("Desktop %d layout changed to %s", desktop.id, mode.value)

    # -------------------------------------------------------------------
    # Apply manage state
    # -------------------------------------------------------------------
    def _apply_manage_state(self):
        """Apply window management state during a manage sequence."""
        output = self.primary_output
        if output is None:
            return

        seat = self.seats[0] if self.seats else None

        # Determine the focused window
        focused = self._get_focused_window()

        # Apply fullscreen state for current desktop
        desktop = self.current_desktop
        if desktop.layout == LayoutMode.FULLSCREEN:
            for win in desktop.windows:
                if not win.closed:
                    if win == focused:
                        if not win.is_fullscreen:
                            win.proxy.fullscreen(output.proxy)
                            win.proxy.inform_fullscreen()
                            win.is_fullscreen = True
                    else:
                        if win.is_fullscreen:
                            win.proxy.exit_fullscreen()
                            win.proxy.inform_not_fullscreen()
                            win.is_fullscreen = False
        else:
            # Ensure no windows are fullscreen in non-fullscreen modes
            for win in desktop.all_windows():
                if not win.closed and win.is_fullscreen:
                    win.proxy.exit_fullscreen()
                    win.proxy.inform_not_fullscreen()
                    win.is_fullscreen = False

        # Propose dimensions for visible windows and inform tiled state
        ua_x, ua_y, ua_w, ua_h = self._usable_area(output)
        if desktop.layout == LayoutMode.MAX:
            for win in desktop.windows:
                if not win.closed:
                    win.proxy.set_tiled(EDGE_ALL)
                    win.proxy.propose_dimensions(ua_w, ua_h)
        elif desktop.layout == LayoutMode.SPLIT:
            half_w = ua_w // 2
            left_visible = self._visible_top(desktop.left_stack)
            right_visible = self._visible_top(desktop.right_stack)
            if left_visible:
                left_visible.proxy.set_tiled(EDGE_ALL)
                left_visible.proxy.propose_dimensions(half_w, ua_h)
            if right_visible:
                right_visible.proxy.set_tiled(EDGE_ALL)
                right_visible.proxy.propose_dimensions(half_w, ua_h)

        # Set focus
        if seat and focused and not focused.closed:
            seat.proxy.focus_window(focused.proxy)
        elif seat:
            seat.proxy.clear_focus()

    # -------------------------------------------------------------------
    # Apply render state
    # -------------------------------------------------------------------
    def _apply_render_state(self):
        """Apply rendering state during a render sequence."""
        output = self.primary_output
        if output is None:
            return

        focused = self._get_focused_window()

        # First: hide all windows on non-current desktops
        for did, desktop in self.desktops.items():
            if did != self.current_desktop_id:
                for win in desktop.all_windows():
                    if not win.closed and win.node:
                        win.proxy.hide()

        # Current desktop
        desktop = self.current_desktop
        self._layout_desktop(desktop, output, focused)

        # Floating overlay
        if self.floating_active:
            self._layout_floating(output, focused)
        else:
            for win in self.floating_stack:
                if not win.closed and win.node:
                    win.proxy.hide()

    def _layout_desktop(self, desktop: Desktop, output: OutputState, focused: Optional[WindowState]):
        """Layout windows on the current desktop."""
        if desktop.layout == LayoutMode.SPLIT:
            self._layout_split(desktop, output, focused)
        else:
            self._layout_single(desktop, output, focused, with_borders=desktop.layout != LayoutMode.FULLSCREEN)

    def _layout_single(self, desktop: Desktop, output: OutputState, focused: Optional[WindowState], with_borders: bool):
        """Fullscreen/Max layout: focused window visible, others hidden."""
        if with_borders:
            ua_x, ua_y, ua_w, ua_h = self._usable_area(output)
        for win in desktop.windows:
            if win.closed:
                continue
            if win == focused:
                win.proxy.show()
                if win.node:
                    if with_borders:
                        win.node.set_position(ua_x, ua_y)
                    win.node.place_top()
                if with_borders:
                    self._set_borders(win, True)
            else:
                win.proxy.hide()

    def _layout_split(self, desktop: Desktop, output: OutputState, focused: Optional[WindowState]):
        """2-split layout: left and right halves, top of each stack visible."""
        ua_x, ua_y, ua_w, ua_h = self._usable_area(output)
        left_visible = self._visible_top(desktop.left_stack)

        # Left stack — always positioned at left edge
        for i, win in enumerate(desktop.left_stack):
            if win.closed:
                continue
            if i == 0:
                win.proxy.show()
                if win.node:
                    win.node.set_position(ua_x, ua_y)
                self._set_borders(win, win == focused)
            else:
                win.proxy.hide()

        # Right stack — right-aligned to the right edge of usable area
        right_visible = self._visible_top(desktop.right_stack)
        if right_visible and right_visible.width > 0:
            right_x = ua_x + ua_w - right_visible.width
        elif left_visible and left_visible.width > 0:
            right_x = ua_x + left_visible.width
        else:
            right_x = ua_x + ua_w // 2
        for i, win in enumerate(desktop.right_stack):
            if win.closed:
                continue
            if i == 0:
                win.proxy.show()
                if win.node:
                    win.node.set_position(right_x, ua_y)
                self._set_borders(win, win == focused)
            else:
                win.proxy.hide()

        # Z-order: ensure visible windows are on top
        if desktop.left_stack and desktop.left_stack[0].node:
            desktop.left_stack[0].node.place_top()
        if desktop.right_stack and desktop.right_stack[0].node:
            desktop.right_stack[0].node.place_top()

    def _layout_floating(self, output: OutputState, focused: Optional[WindowState]):
        """Layout floating overlay windows."""
        for win in reversed(self.floating_stack):
            if win.closed:
                continue
            win.proxy.show()
            if win.node:
                win.node.set_position(win.pos_x, win.pos_y)
                win.node.place_top()
            self._set_borders(win, win == focused)

    @staticmethod
    def _visible_top(stack: list) -> Optional[WindowState]:
        """Return the first non-closed window in a stack, or None."""
        for win in stack:
            if not win.closed:
                return win
        return None

    def _set_borders(self, win: WindowState, is_focused: bool):
        if self.config.border_width <= 0:
            return
        c = _BORDER_FOCUSED if is_focused else _BORDER_UNFOCUSED
        win.proxy.set_borders(EDGE_ALL, self.config.border_width, *c)

    # -------------------------------------------------------------------
    # Interactive move/resize
    # -------------------------------------------------------------------
    def _start_interactive_op(self, seat: SeatState, win: WindowState, mode: str):
        """Start an interactive pointer move or resize operation."""
        if seat.op_active:
            return
        seat.op_active = True
        seat.op_window = win
        seat.op_mode = mode
        seat.op_dx = seat.op_dy = 0
        seat.op_released = False
        if mode == "move":
            win.move_start_x, win.move_start_y = win.pos_x, win.pos_y
        else:
            win.move_start_x, win.move_start_y = win.width, win.height
        seat.proxy.op_start_pointer()

    def _handle_interactive_op(self, seat: SeatState):
        """Handle ongoing interactive operation during manage sequence."""
        win = seat.op_window
        if win is None or win.closed:
            seat.op_active = False
            seat.proxy.op_end()
            return

        if seat.op_mode == "move":
            win.pos_x = win.move_start_x + seat.op_dx
            win.pos_y = win.move_start_y + seat.op_dy
        elif seat.op_mode == "resize":
            new_w = max(100, win.move_start_x + seat.op_dx)
            new_h = max(100, win.move_start_y + seat.op_dy)
            win.proxy.propose_dimensions(new_w, new_h)

        if seat.op_released:
            seat.op_active = False
            seat.proxy.op_end()
            seat.op_window = None

    # -------------------------------------------------------------------
    # Keybinding setup
    # -------------------------------------------------------------------
    def setup_keybindings(self):
        """Register all keybindings with the compositor."""
        if not self.seats:
            logger.warning("No seats available for keybindings")
            return

        seat = self.seats[0]

        # Helper to bind a key
        def bind_key(keysym, modifiers, callback):
            binding = self.xkb_bindings_proxy.get_xkb_binding(seat.proxy, keysym, modifiers)
            def _on_pressed(p, cb=callback, ks=keysym):
                logger.debug("KEY PRESSED: keysym=0x%x", ks)
                cb()
            binding.dispatcher["pressed"] = _on_pressed
            binding.dispatcher["released"] = lambda p: None
            binding.dispatcher["stop_repeat"] = lambda p: None
            self.key_bindings[id(binding)] = (binding, callback)
            self.pending_bindings_to_enable.append(binding)

        def bind_pointer(button, modifiers, press_cb, release_cb=None):
            binding = seat.proxy.get_pointer_binding(button, modifiers)
            binding.dispatcher["pressed"] = lambda p: press_cb()
            binding.dispatcher["released"] = lambda p: (release_cb() if release_cb else None)
            self.pointer_bindings[id(binding)] = (binding, press_cb, release_cb)
            self.pending_bindings_to_enable.append(binding)

        S, SS = MOD_SUPER, MOD_SUPER | MOD_SHIFT
        key_table = [
            # Desktop switching & window moving
            (XKB_KEY_1, S, "_action_switch_desktop", (1,)),
            (XKB_KEY_2, S, "_action_switch_desktop", (2,)),
            (XKB_KEY_3, S, "_action_switch_desktop", (3,)),
            (XKB_KEY_4, S, "_action_switch_desktop", (4,)),
            (XKB_KEY_1, SS, "_action_move_to_desktop", (1,)),
            (XKB_KEY_2, SS, "_action_move_to_desktop", (2,)),
            (XKB_KEY_3, SS, "_action_move_to_desktop", (3,)),
            (XKB_KEY_4, SS, "_action_move_to_desktop", (4,)),
            # Floating
            (XKB_KEY_space, S, "_action_toggle_floating", ()),
            (XKB_KEY_space, SS, "_action_move_to_floating", ()),
            # Layout control
            (XKB_KEY_f, S, "_action_set_layout", (LayoutMode.FULLSCREEN,)),
            (XKB_KEY_m, S, "_action_set_layout", (LayoutMode.MAX,)),
            (XKB_KEY_s, S, "_action_set_layout", (LayoutMode.SPLIT,)),
            # Window navigation
            (XKB_KEY_j, S, "_action_cycle_next", ()),
            (XKB_KEY_k, S, "_action_cycle_prev", ()),
            (XKB_KEY_Tab, S, "_action_focus_other_side", ()),
            (XKB_KEY_h, S, "_action_focus_side", (Side.LEFT,)),
            (XKB_KEY_l, S, "_action_focus_side", (Side.RIGHT,)),
            (XKB_KEY_n, SS, "_action_cycle_side", ()),
            (XKB_KEY_n, S, "_action_spawn", ("flatpak run --command=swaync-client sh.ironforge.swaync -t",)),
            # Window manipulation
            (XKB_KEY_o, S, "_action_move_to_other_side", ()),
            (XKB_KEY_Tab, SS, "_action_move_to_other_side", ()),
            (XKB_KEY_h, SS, "_action_move_to_side", (Side.LEFT,)),
            (XKB_KEY_l, SS, "_action_move_to_side", (Side.RIGHT,)),
            (XKB_KEY_k, SS, "_action_move_in_stack", (-1,)),
            (XKB_KEY_j, SS, "_action_move_in_stack", (1,)),
            (XKB_KEY_q, S, "_action_close_window", ()),
            # General
            (XKB_KEY_Return, S, "_action_spawn", (self.config.terminal_cmd,)),
            (XKB_KEY_d, S, "_action_spawn", (self.config.launcher_cmd,)),
            (XKB_KEY_p, S, "_action_spawn", (self.config.launcher_cmd,)),
            (XKB_KEY_r, SS, "_action_restart_wm", ()),
            # Screenshots
            (XKB_KEY_g, S, "_action_screenshot_region", ()),
            (XKB_KEY_g, SS, "_action_screenshot_region_file", ()),
            (XKB_KEY_Print, 0, "_action_screenshot_full", ()),
        ]
        for keysym, mods, method, args in key_table:
            bind_key(keysym, mods, lambda m=method, a=args: getattr(self, m)(*a))

        bind_pointer(BTN_LEFT, S, lambda: self._action_pointer_op("move"))
        bind_pointer(BTN_RIGHT, S, lambda: self._action_pointer_op("resize"))

        # Request a manage sequence to enable bindings
        self.wm_proxy.manage_dirty()

        logger.info("Keybindings registered")

    # -------------------------------------------------------------------
    # Keybinding actions
    # -------------------------------------------------------------------
    def _action_switch_desktop(self, desktop_id: int):
        self._switch_desktop(desktop_id)
        self.wm_proxy.manage_dirty()

    def _action_move_to_desktop(self, desktop_id: int):
        focused = self._get_focused_window()
        if focused:
            self._move_window_to_desktop(focused, desktop_id)
        self.wm_proxy.manage_dirty()

    def _action_toggle_floating(self):
        self.floating_active = not self.floating_active
        self.needs_layout = True
        self.wm_proxy.manage_dirty()
        logger.info("Floating overlay %s", "activated" if self.floating_active else "deactivated")

    def _action_move_to_floating(self):
        focused = self._get_focused_window()
        if focused:
            if focused.desktop_id == 0:
                # Already floating — move back to current tiled desktop
                self._move_window_to_desktop(focused, self.current_desktop_id)
            else:
                self._move_window_to_desktop(focused, 0)
        self.wm_proxy.manage_dirty()

    def _action_set_layout(self, mode: LayoutMode):
        self._set_layout_mode(mode)
        self.wm_proxy.manage_dirty()

    def _action_cycle_next(self):
        if self.floating_active and self.floating_stack:
            # Rotate floating stack
            if len(self.floating_stack) > 1:
                self.floating_stack.append(self.floating_stack.pop(0))
            self.wm_proxy.manage_dirty()
            return

        desktop = self.current_desktop
        if desktop.layout == LayoutMode.SPLIT:
            self._action_cycle_side()
            return

        if desktop.windows:
            desktop.focused_index = (desktop.focused_index + 1) % len(desktop.windows)
        self.wm_proxy.manage_dirty()

    def _action_cycle_prev(self):
        if self.floating_active and self.floating_stack:
            if len(self.floating_stack) > 1:
                self.floating_stack.insert(0, self.floating_stack.pop())
            self.wm_proxy.manage_dirty()
            return

        desktop = self.current_desktop
        if desktop.layout == LayoutMode.SPLIT:
            # Cycle in reverse on current side
            stack = desktop.left_stack if desktop.focused_side == Side.LEFT else desktop.right_stack
            if len(stack) > 1:
                stack.insert(0, stack.pop())
            self.wm_proxy.manage_dirty()
            return

        if desktop.windows:
            desktop.focused_index = (desktop.focused_index - 1) % len(desktop.windows)
        self.wm_proxy.manage_dirty()

    def _action_focus_other_side(self):
        desktop = self.current_desktop
        if desktop.layout != LayoutMode.SPLIT:
            return
        if desktop.focused_side == Side.LEFT:
            desktop.focused_side = Side.RIGHT
        else:
            desktop.focused_side = Side.LEFT
        self.wm_proxy.manage_dirty()

    def _action_focus_side(self, side: Side):
        desktop = self.current_desktop
        if desktop.layout != LayoutMode.SPLIT:
            return
        if desktop.focused_side != side:
            desktop.focused_side = side
            self.wm_proxy.manage_dirty()

    def _action_cycle_side(self):
        desktop = self.current_desktop
        if desktop.layout != LayoutMode.SPLIT:
            return
        stack = desktop.left_stack if desktop.focused_side == Side.LEFT else desktop.right_stack
        if len(stack) > 1:
            stack.append(stack.pop(0))
        self.wm_proxy.manage_dirty()

    def _action_move_to_other_side(self):
        desktop = self.current_desktop
        if desktop.layout != LayoutMode.SPLIT:
            return
        focused = desktop.get_focused_window()
        if focused is None:
            return
        if focused.side == Side.LEFT:
            self._move_window_to_side(desktop, focused, Side.RIGHT)
        else:
            self._move_window_to_side(desktop, focused, Side.LEFT)
        self.wm_proxy.manage_dirty()

    def _action_move_to_side(self, side: Side):
        desktop = self.current_desktop
        if desktop.layout != LayoutMode.SPLIT:
            return
        focused = desktop.get_focused_window()
        if focused is None or focused.side == side:
            return
        self._move_window_to_side(desktop, focused, side)
        self.wm_proxy.manage_dirty()

    def _move_window_to_side(self, desktop, win, side):
        if win in desktop.left_stack:
            desktop.left_stack.remove(win)
        if win in desktop.right_stack:
            desktop.right_stack.remove(win)
        win.side = side
        if side == Side.LEFT:
            desktop.left_stack.insert(0, win)
        else:
            desktop.right_stack.insert(0, win)
        desktop.focused_side = side

    def _action_move_in_stack(self, direction: int):
        desktop = self.current_desktop
        if desktop.layout != LayoutMode.SPLIT:
            return
        stack = desktop.left_stack if desktop.focused_side == Side.LEFT else desktop.right_stack
        focused = desktop.get_focused_window()
        if focused is None or focused not in stack:
            return
        idx = stack.index(focused)
        new_idx = idx + direction
        if 0 <= new_idx < len(stack):
            stack[idx], stack[new_idx] = stack[new_idx], stack[idx]
        self.wm_proxy.manage_dirty()

    def _action_close_window(self):
        focused = self._get_focused_window()
        if focused and not focused.closed:
            focused.proxy.close()

    def _action_spawn(self, cmd: str):
        try:
            subprocess.Popen(
                cmd, shell=True,
                stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                start_new_session=True
            )
            logger.info("Spawned: %s", cmd)
        except Exception as e:
            logger.error("Failed to spawn %s: %s", cmd, e)

    def _action_screenshot_region(self):
        self._action_spawn('grim -g "$(slurp)" - | wl-copy -t image/png')

    def _action_screenshot_region_file(self):
        os.makedirs(os.path.expanduser("~/Pictures"), exist_ok=True)
        path = os.path.expanduser(f"~/Pictures/screenshot-{int(time.time())}.png")
        self._action_spawn(f'grim -g "$(slurp)" {path}')

    def _action_screenshot_full(self):
        self._action_spawn("grim - | wl-copy -t image/png")

    def _action_restart_wm(self):
        """Hot-reload: terminate managed processes, clean shutdown, re-exec."""
        logger.info("Hot-reloading WM (re-exec)...")
        if self.process_manager:
            self.process_manager.terminate_all()
            self.process_manager.close_pipe()
            self.process_manager = None
        self.shutdown()
        python = sys.executable
        os.execv(python, [python] + sys.argv)

    def _action_pointer_op(self, mode: str):
        if not self.seats:
            return
        seat = self.seats[0]
        win = seat.pointer_entered_window
        if win and win.desktop_id == 0:
            self._start_interactive_op(seat, win, mode)

    # -------------------------------------------------------------------
    # Helpers
    # -------------------------------------------------------------------
    def _find_seat(self, seat_proxy) -> Optional[SeatState]:
        for s in self.seats:
            if s.proxy == seat_proxy:
                return s
        return None

    def _apply_xkb_keymap(self):
        """Apply XKB keymap via river-xkb-config-v1 protocol at runtime."""
        if self.xkb_config_proxy is None:
            if self.config.xkb_layout or self.config.xkb_model or \
               self.config.xkb_variant or self.config.xkb_options:
                logger.warning("river_xkb_config_v1 not available; cannot apply XKB keymap")
            return

        if not any((self.config.xkb_layout, self.config.xkb_model,
                     self.config.xkb_variant, self.config.xkb_options)):
            return

        # Build xkbcli command
        cmd = ["xkbcli", "compile-keymap"]
        if self.config.xkb_layout:
            cmd += ["--layout", self.config.xkb_layout]
        if self.config.xkb_model:
            cmd += ["--model", self.config.xkb_model]
        if self.config.xkb_variant:
            cmd += ["--variant", self.config.xkb_variant]
        if self.config.xkb_options:
            cmd += ["--options", self.config.xkb_options]

        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)
            if result.returncode != 0:
                logger.error("xkbcli compile-keymap failed: %s", result.stderr.strip())
                return
            keymap_text = result.stdout
        except FileNotFoundError:
            logger.error("xkbcli not found; cannot compile XKB keymap")
            return
        except subprocess.TimeoutExpired:
            logger.error("xkbcli compile-keymap timed out")
            return

        # Write keymap to a memfd for the compositor to mmap
        keymap_bytes = keymap_text.encode("utf-8")
        fd = os.memfd_create("xkb-keymap")
        os.write(fd, keymap_bytes)
        os.lseek(fd, 0, os.SEEK_SET)

        # Create the keymap object (format 1 = XKB_KEYMAP_FORMAT_TEXT_V1)
        keymap_proxy = self.xkb_config_proxy.create_keymap(fd, 1)
        os.close(fd)

        def _on_keymap_success(proxy):
            self.xkb_keymap_obj = proxy
            logger.info("Applied XKB keymap (layout=%s model=%s variant=%s options=%s)",
                        self.config.xkb_layout or "(default)",
                        self.config.xkb_model or "(default)",
                        self.config.xkb_variant or "(default)",
                        self.config.xkb_options or "(default)")
            # Apply to any keyboards we already know about
            for kb in self.xkb_keyboards:
                kb.set_keymap(self.xkb_keymap_obj)

        def _on_keymap_failure(proxy, error_msg):
            logger.error("XKB keymap creation failed: %s", error_msg)

        keymap_proxy.dispatcher["success"] = _on_keymap_success
        keymap_proxy.dispatcher["failure"] = _on_keymap_failure

    def _on_xkb_keyboard(self, xkb_config_proxy, keyboard_proxy):
        """Handle new xkb keyboard from river_xkb_config_v1."""
        self.xkb_keyboards.append(keyboard_proxy)

        def _on_keyboard_removed(proxy):
            if proxy in self.xkb_keyboards:
                self.xkb_keyboards.remove(proxy)
            logger.info("XKB keyboard removed")

        keyboard_proxy.dispatcher["removed"] = _on_keyboard_removed

        # If keymap already created, apply it to this keyboard
        if self.xkb_keymap_obj is not None:
            keyboard_proxy.set_keymap(self.xkb_keymap_obj)
            logger.info("Applied XKB keymap to new keyboard")
        else:
            logger.debug("XKB keyboard appeared (keymap not yet ready)")

    # -------------------------------------------------------------------
    # Main loop
    # -------------------------------------------------------------------
    def run(self):
        """Main event loop."""
        self.connect()

        # Do an initial roundtrip to get outputs and seats
        self.display.roundtrip()

        # Apply XKB keymap via river-xkb-config-v1 protocol
        self._apply_xkb_keymap()
        self.display.roundtrip()  # process keymap success + apply to keyboards

        # Setup keybindings
        self.setup_keybindings()

        # Flush to send all requests
        self.display.flush()

        # Start managed processes (after protocols are bound)
        if self.config.processes:
            self.process_manager = ProcessManager(self.config.processes)
            self.process_manager.setup_sigchld_pipe()
            self.process_manager.start_all()

        logger.info("Entering main event loop")

        if self.process_manager is not None:
            self._run_poll_loop()
        else:
            self._run_simple_loop()

        logger.error("Event loop exited, self.running=%s", self.running)
        self.shutdown()

    def _run_simple_loop(self):
        """Original blocking dispatch loop (no managed processes)."""
        while self.running:
            try:
                ret = self.display.dispatch(block=True)
                if ret < 0:
                    logger.error("display.dispatch returned %d, connection lost", ret)
                    break
                self.display.flush()
            except KeyboardInterrupt:
                logger.info("Interrupted, shutting down")
                break
            except Exception as e:
                logger.error("Error in event loop: %s", e, exc_info=True)
                continue

    def _run_poll_loop(self):
        """Poll-based event loop monitoring both Wayland fd and SIGCHLD pipe."""
        pm = self.process_manager
        cancel_read = ProcessManager._get_cancel_read()
        display_ptr = self.display._ptr
        # Convert CFFI pointer to ctypes-compatible int for cancel_read
        display_ptr_int = int(_wl_ffi.cast("uintptr_t", display_ptr))
        wl_fd = self.display.get_fd()
        pipe_fd = pm.pipe_fd

        poller = select.poll()
        poller.register(wl_fd, select.POLLIN)
        poller.register(pipe_fd, select.POLLIN)

        while self.running:
            try:
                # Dispatch any already-queued events and flush outgoing
                self.display.dispatch(block=False)
                self.display.flush()

                # Prepare for reading — loop until the display queue is drained
                while _wl_lib.wl_display_prepare_read(display_ptr) != 0:
                    self.display.dispatch(block=False)
                self.display.flush()

                # Calculate poll timeout from restart schedule
                next_restart = pm.process_restarts()
                if next_restart is not None:
                    timeout_ms = max(1, int(next_restart * 1000))
                else:
                    timeout_ms = -1  # block indefinitely

                ready = poller.poll(timeout_ms)
                ready_fds = {fd for fd, ev in ready}

                if wl_fd in ready_fds:
                    _wl_lib.wl_display_read_events(display_ptr)
                else:
                    cancel_read(display_ptr_int)

                if pipe_fd in ready_fds:
                    pm.handle_sigchld()

                # Process any due restarts (also covers timeout wakeups)
                pm.process_restarts()

            except KeyboardInterrupt:
                logger.info("Interrupted, shutting down")
                break
            except Exception as e:
                logger.error("Error in poll loop: %s", e, exc_info=True)
                # Cancel any pending read to avoid deadlock
                try:
                    cancel_read(display_ptr_int)
                except Exception:
                    pass
                continue

    def shutdown(self):
        """Clean shutdown."""
        logger.info("Shutting down wm2")
        if self.process_manager:
            self.process_manager.terminate_all()
            self.process_manager.close_pipe()
        if self.wm_proxy:
            try:
                self.wm_proxy.stop()
            except Exception:
                pass
        if self.display:
            try:
                self.display.disconnect()
            except Exception:
                pass


def main():
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(asctime)s [%(name)s] %(levelname)s: %(message)s",
        datefmt="%H:%M:%S",
    )

    config = Config.load()
    wm = RiverWM(config)

    # Handle SIGTERM gracefully
    def sigterm_handler(signum, frame):
        wm.running = False
    signal.signal(signal.SIGTERM, sigterm_handler)

    wm.run()
    sys.exit(1)


if __name__ == "__main__":
    main()
