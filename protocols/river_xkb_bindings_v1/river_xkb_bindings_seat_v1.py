# This file has been autogenerated by the pywayland scanner

# SPDX-FileCopyrightText: Â© 2025 Isaac Freund
# SPDX-License-Identifier: MIT
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

from __future__ import annotations

from pywayland.protocol_core import Global, Interface, Proxy, Resource


class RiverXkbBindingsSeatV1(Interface):
    """Xkb bindings seat

    This object manages xkb bindings state associated with a specific seat.
    """

    name = "river_xkb_bindings_seat_v1"
    version = 2


class RiverXkbBindingsSeatV1Proxy(Proxy[RiverXkbBindingsSeatV1]):
    interface = RiverXkbBindingsSeatV1

    @RiverXkbBindingsSeatV1.request(version=2)
    def destroy(self) -> None:
        """Destroy the object

        This request indicates that the client will no longer use the object
        and that it may be safely destroyed.
        """
        self._marshal(0)
        self._destroy()

    @RiverXkbBindingsSeatV1.request(version=2)
    def ensure_next_key_eaten(self) -> None:
        """Ensure the next key press event is eaten

        Ensure that the next non-modifier key press and corresponding release
        events for this seat are not sent to the currently focused surface.

        If the next non-modifier key press triggers a binding, the
        pressed/released events are sent to the
        :class:`~pywayland.protocol.river_xkb_bindings_v1.RiverXkbBindingV1`
        object as usual.

        If the next non-modifier key press does not trigger a binding, the
        ate_unbound_key event is sent instead.

        Rationale: the window manager may wish to implement "chorded"
        keybindings where triggering a binding activates a "submap" with a
        different set of keybindings. Without a way to eat the next key press
        event, there is no good way for the window manager to know that it
        should error out and exit the submap when a key not bound in the submap
        is pressed.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(1)

    @RiverXkbBindingsSeatV1.request(version=2)
    def cancel_ensure_next_key_eaten(self) -> None:
        """Cancel an ensure_next_key_eaten request

        This requests cancels the effect of the latest ensure_next_key_eaten
        request if no key has been eaten due to the request yet. This request
        has no effect if a key has already been eaten or no
        ensure_next_key_eaten was made.

        Rationale: the window manager may wish cancel an uncompleted "chorded"
        keybinding after a timeout of a few seconds. Note that since this
        timeout use-case requires the window manager to trigger a manage
        sequence with the :func:`RiverWindowManagerV1.manage_dirty()
        <pywayland.protocol.river_window_management_v1.RiverWindowManagerV1.manage_dirty>`
        request it is possible that the ate_unbound_key key event may be sent
        before the window manager has a chance to make the
        cancel_ensure_next_key_eaten request.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(2)


class RiverXkbBindingsSeatV1Resource(Resource):
    interface = RiverXkbBindingsSeatV1

    @RiverXkbBindingsSeatV1.event(version=2)
    def ate_unbound_key(self) -> None:
        """An unbound key press event was eaten

        An unbound key press event was eaten due to the ensure_next_key_eaten
        request.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.
        """
        self._post_event(0)


class RiverXkbBindingsSeatV1Global(Global):
    interface = RiverXkbBindingsSeatV1


RiverXkbBindingsSeatV1._gen_c()
RiverXkbBindingsSeatV1.proxy_class = RiverXkbBindingsSeatV1Proxy
RiverXkbBindingsSeatV1.resource_class = RiverXkbBindingsSeatV1Resource
RiverXkbBindingsSeatV1.global_class = RiverXkbBindingsSeatV1Global
