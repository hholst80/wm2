# This file has been autogenerated by the pywayland scanner

# SPDX-FileCopyrightText: Â© 2025 Isaac Freund
# SPDX-License-Identifier: MIT
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

from __future__ import annotations

from pywayland.protocol_core import (
    Argument,
    ArgumentType,
    Global,
    Interface,
    Proxy,
    Resource,
)


class RiverXkbBindingV1(Interface):
    """Configure a xkb key binding, receive trigger events

    This object allows the window manager to configure a xkbcommon key binding
    and receive events when the key binding is triggered.

    The new key binding is not enabled until the enable request is made during
    a manage sequence.

    Normally, all key events are sent to the surface with keyboard focus by the
    compositor. Key events that trigger a key binding are not sent to the
    surface with keyboard focus.

    If multiple key bindings would be triggered by a single physical key event
    on the compositor side, it is compositor policy which key binding(s) will
    receive press/release events or if all of the matched key bindings receive
    press/release events.

    Key bindings might be matched by the same physical key event due to shared
    keysym and modifiers. The layout override feature may also cause the same
    physical key event to trigger two key bindings with different keysyms and
    different layout overrides configured.
    """

    name = "river_xkb_binding_v1"
    version = 2


class RiverXkbBindingV1Proxy(Proxy[RiverXkbBindingV1]):
    interface = RiverXkbBindingV1

    @RiverXkbBindingV1.request()
    def destroy(self) -> None:
        """Destroy the xkb binding object

        This request indicates that the client will no longer use the xkb key
        binding object and that it may be safely destroyed.
        """
        self._marshal(0)
        self._destroy()

    @RiverXkbBindingV1.request(
        Argument(ArgumentType.Uint),
    )
    def set_layout_override(self, layout: int) -> None:
        """Override currently active xkb layout

        Specify an xkb layout that should be used to translate key events for
        the purpose of triggering this key binding irrespective of the
        currently active xkb layout.

        The layout argument is a 0-indexed xkbcommon layout number for the
        keyboard that generated the key event.

        If this request is never made, the currently active xkb layout of the
        keyboard that generated the key event will be used.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.

        :param layout:
            0-indexed xkbcommon layout
        :type layout:
            `ArgumentType.Uint`
        """
        self._marshal(1, layout)

    @RiverXkbBindingV1.request()
    def enable(self) -> None:
        """Enable the key binding

        This request should be made after all initial configuration has been
        completed and the window manager wishes the key binding to be able to
        be triggered.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(2)

    @RiverXkbBindingV1.request()
    def disable(self) -> None:
        """Disable the key binding

        This request may be used to temporarily disable the key binding. It may
        be later re-enabled with the enable request.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(3)


class RiverXkbBindingV1Resource(Resource):
    interface = RiverXkbBindingV1

    @RiverXkbBindingV1.event()
    def pressed(self) -> None:
        """The key triggering the binding has been pressed

        This event indicates that the physical key triggering the binding has
        been pressed.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        The compositor should wait for the manage sequence to complete before
        processing further input events. This allows the window manager client
        to, for example, modify key bindings and keyboard focus without racing
        against future input events. The window manager should of course
        respond as soon as possible as the capacity of the compositor to buffer
        incoming input events is finite.
        """
        self._post_event(0)

    @RiverXkbBindingV1.event()
    def released(self) -> None:
        """The key triggering the binding has been released

        This event indicates that the physical key triggering the binding has
        been released.

        Releasing the modifiers for the binding without releasing the "main"
        physical key that produces the bound keysym does not trigger the
        release event. This event is sent when the "main" key is released, even
        if the modifiers have changed since the pressed event.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        The compositor should wait for the manage sequence to complete before
        processing further input events. This allows the window manager client
        to, for example, modify key bindings and keyboard focus without racing
        against future input events. The window manager should of course
        respond as soon as possible as the capacity of the compositor to buffer
        incoming input events is finite.
        """
        self._post_event(1)

    @RiverXkbBindingV1.event(version=2)
    def stop_repeat(self) -> None:
        """Repeating should be stopped

        This event indicates that repeating should be stopped for the binding
        if the window manager has been repeating some action since the pressed
        event.

        This event is generally sent when some other (possible unbound) key is
        pressed after the pressed event is sent and before the released event
        is sent for this binding.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.
        """
        self._post_event(2)


class RiverXkbBindingV1Global(Global):
    interface = RiverXkbBindingV1


RiverXkbBindingV1._gen_c()
RiverXkbBindingV1.proxy_class = RiverXkbBindingV1Proxy
RiverXkbBindingV1.resource_class = RiverXkbBindingV1Resource
RiverXkbBindingV1.global_class = RiverXkbBindingV1Global
