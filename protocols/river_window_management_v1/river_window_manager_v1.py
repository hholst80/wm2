# This file has been autogenerated by the pywayland scanner

# SPDX-FileCopyrightText: Â© 2024 Isaac Freund
# SPDX-License-Identifier: MIT
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

from __future__ import annotations

import enum

from pywayland.protocol_core import (
    Argument,
    ArgumentType,
    Global,
    Interface,
    Proxy,
    Resource,
)

from ..wayland import WlSurface
from .river_output_v1 import RiverOutputV1
from .river_seat_v1 import RiverSeatV1
from .river_shell_surface_v1 import RiverShellSurfaceV1
from .river_window_v1 import RiverWindowV1


class RiverWindowManagerV1(Interface):
    """Window manager global interface

    This global interface should only be advertised to the window manager
    process. Only one window management client may be active at a time. The
    compositor should use the unavailable event if necessary to enforce this.

    There are two disjoint categories of state managed by this protocol:

    Window management state influences the communication between the server and
    individual window clients (e.g. xdg_toplevels). Window management state
    includes window dimensions, fullscreen state, keyboard focus, keyboard
    bindings, and more.

    Rendering state only affects the rendered output of the compositor and does
    not influence communication between the server and individual window
    clients. Rendering state includes the position and rendering order of
    windows, shell surfaces, decoration surfaces, borders, and more.

    Window management state may only be modified by the window manager as part
    of a manage sequence. A manage sequence is started with the manage_start
    event and ended with the manage_finish request. It is a protocol error to
    modify window management state outside of a manage sequence.

    A manage sequence is always followed by at least one render sequence. A
    render sequence is started with the render_start event and ended with the
    render_finish request.

    Rendering state may be modified by the window manager during a manage
    sequence or a render sequence. Regardless of when the rendering state is
    modified, it is applied with the next render_finish request. It is a
    protocol error to modify rendering state outside of a manage or render
    sequence.

    The server will start a manage sequence by sending new state and the
    manage_start event as soon as possible whenever there is a change in state
    that must be communicated with the window manager.

    If the window manager client needs to ensure a manage sequence is started
    due to a state change the compositor is not aware of, it may send the
    manage_dirty request.

    The server will start a render sequence by sending new state and the
    render_start event as soon as possible whenever there is a change in window
    dimensions that must be communicated with the window manager. Multiple
    render sequences may be made consecutively without a manage sequence in
    between, for example if a window independently changes its own dimensions.

    To summarize, the main loop of this protocol is as follows:

    1. The server sends events indicating all changes since the last    manage
    sequence followed by the manage_start event.

    2. The client sends requests modifying window management state or
    rendering state (as defined above) followed by the manage_finish
    request.

    3. The server sends new state to windows and waits for responses.

    4. The server sends new window dimensions to the client followed by the
    render_start event.

    5. The client sends requests modifying rendering state (as defined above)
    followed by the render_finish request.

    6. If window dimensions change, loop back to step 4.    If state that
    requires a manage sequence changes or if the client makes    a manage_dirty
    request, loop back to step 1.

    For the purposes of frame perfection, the server may delay rendering new
    state committed by the windows in step 3 until after step 5 is finished.

    It is a protocol error for the client to make a manage_finish or
    render_finish request that violates this ordering.
    """

    name = "river_window_manager_v1"
    version = 3

    class error(enum.IntEnum):
        sequence_order = 0
        role = 1
        unresponsive = 2


class RiverWindowManagerV1Proxy(Proxy[RiverWindowManagerV1]):
    interface = RiverWindowManagerV1

    @RiverWindowManagerV1.request()
    def stop(self) -> None:
        """Stop sending events

        This request indicates that the client no longer wishes to receive
        events on this object.

        The Wayland protocol is asynchronous, which means the server may send
        further events until the stop request is processed. The client must
        wait for a :func:`RiverWindowManagerV1.finished()` event before
        destroying this object.
        """
        self._marshal(0)

    @RiverWindowManagerV1.request()
    def destroy(self) -> None:
        """Destroy the :class:`RiverWindowManagerV1` object

        This request should be called after the finished event has been
        received to complete destruction of the object.

        If a client wishes to destroy this object it should send a
        :func:`RiverWindowManagerV1.stop()` request and wait for a
        :func:`RiverWindowManagerV1.finished()` event. Once the finished event
        is received it is safe to destroy this object and any other objects
        created through this interface.
        """
        self._marshal(1)
        self._destroy()

    @RiverWindowManagerV1.request()
    def manage_finish(self) -> None:
        """Finish a manage sequence

        This request indicates that the client has made all changes to window
        management state it wishes to include in the current manage sequence
        and that the server should atomically send these state changes to the
        windows and continue with the manage sequence.

        After sending this request, it is a protocol error for the client to
        make further changes to window management state until the next
        manage_start event is received.

        See the description of the :class:`RiverWindowManagerV1` interface for
        a complete overview of the manage/render sequence loop.
        """
        self._marshal(2)

    @RiverWindowManagerV1.request()
    def manage_dirty(self) -> None:
        """Ensure a manage sequence is started

        This request ensures a manage sequence is started and that a
        manage_start event is sent by the server. If this request is made
        during an ongoing manage sequence, a new manage sequence will be
        started as soon as the current one is completed.

        The client may want to use this request due to an internal state change
        that the compositor is not aware of (e.g. a dbus event) which should
        affect window management or rendering state.
        """
        self._marshal(3)

    @RiverWindowManagerV1.request()
    def render_finish(self) -> None:
        """Finish a render sequence

        This request indicates that the client has made all changes to
        rendering state it wishes to include in the current manage sequence and
        that the server should atomically apply and display these state changes
        to the user.

        After sending this request, it is a protocol error for the client to
        make further changes to rendering state until the next manage_start or
        render_start event is received, whichever comes first.

        See the description of the :class:`RiverWindowManagerV1` interface for
        a complete overview of the manage/render sequence loop.
        """
        self._marshal(4)

    @RiverWindowManagerV1.request(
        Argument(ArgumentType.NewId, interface=RiverShellSurfaceV1),
        Argument(ArgumentType.Object, interface=WlSurface),
    )
    def get_shell_surface(self, surface: WlSurface) -> Proxy[RiverShellSurfaceV1]:
        """Assign the :class:`~pywayland.protocol.river_window_management_v1.RiverShellSurfaceV1` surface role

        Create a new shell surface for window manager UI and assign the
        :class:`~pywayland.protocol.river_window_management_v1.RiverShellSurfaceV1`
        role to the surface.

        Providing a :class:`~pywayland.protocol.wayland.WlSurface` which
        already has a role or already has a buffer attached or committed is a
        protocol error.

        :param surface:
        :type surface:
            :class:`~pywayland.protocol.wayland.WlSurface`
        :returns:
            :class:`~pywayland.protocol.river_window_management_v1.RiverShellSurfaceV1`
        """
        id = self._marshal_constructor(5, RiverShellSurfaceV1, surface)
        return id


class RiverWindowManagerV1Resource(Resource):
    interface = RiverWindowManagerV1

    @RiverWindowManagerV1.event()
    def unavailable(self) -> None:
        """Window management unavailable

        This event indicates that window management is not available to the
        client, perhaps due to another window management client already
        running. The circumstances causing this event to be sent are compositor
        policy.

        If sent, this event is guaranteed to be the first and only event sent
        by the server.

        The server will send no further events on this object. The client
        should destroy this object and all objects created through this
        interface.
        """
        self._post_event(0)

    @RiverWindowManagerV1.event()
    def finished(self) -> None:
        """The server has finished with the window manager

        This event indicates that the server will send no further events on
        this object. The client should destroy the object. See
        :func:`RiverWindowManagerV1.destroy()` for more information.
        """
        self._post_event(1)

    @RiverWindowManagerV1.event()
    def manage_start(self) -> None:
        """Start a manage sequence

        This event indicates that the server has sent events indicating all
        state changes since the last manage sequence.

        In response to this event, the client should make requests modifying
        window management state as it chooses. Then, the client must make the
        manage_finish request.

        See the description of the :class:`RiverWindowManagerV1` interface for
        a complete overview of the manage/render sequence loop.
        """
        self._post_event(2)

    @RiverWindowManagerV1.event()
    def render_start(self) -> None:
        """Start a render sequence

        This event indicates that the server has sent all
        :func:`RiverNodeV1.position()
        <pywayland.protocol.river_window_management_v1.RiverNodeV1.position>`
        and :func:`RiverWindowV1.dimensions()
        <pywayland.protocol.river_window_management_v1.RiverWindowV1.dimensions>`
        events necessary.

        In response to this event, the client should make requests modifying
        rendering state as it chooses. Then, the client must make the
        render_finish request.

        See the description of the :class:`RiverWindowManagerV1` interface for
        a complete overview of the manage/render sequence loop.
        """
        self._post_event(3)

    @RiverWindowManagerV1.event()
    def session_locked(self) -> None:
        """The session has been locked

        This event indicates that the session has been locked.

        The window manager may wish to restrict which key bindings are
        available while locked or otherwise use this information.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.
        """
        self._post_event(4)

    @RiverWindowManagerV1.event()
    def session_unlocked(self) -> None:
        """The session has been unlocked

        This event indicates that the session has been unlocked.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.
        """
        self._post_event(5)

    @RiverWindowManagerV1.event(
        Argument(ArgumentType.NewId, interface=RiverWindowV1),
    )
    def window(self, id: RiverWindowV1) -> None:
        """New window

        A new window has been created.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        :param id:
        :type id:
            :class:`~pywayland.protocol.river_window_management_v1.RiverWindowV1`
        """
        self._post_event(6, id)

    @RiverWindowManagerV1.event(
        Argument(ArgumentType.NewId, interface=RiverOutputV1),
    )
    def output(self, id: RiverOutputV1) -> None:
        """New output

        A new logical output has been created, perhaps due to a new physical
        monitor being plugged in or perhaps due to a change in configuration.

        This event will be followed by :func:`RiverOutputV1.position()
        <pywayland.protocol.river_window_management_v1.RiverOutputV1.position>`
        and dimensions events as well as a manage_start event after all other
        new state has been sent by the server.

        :param id:
        :type id:
            :class:`~pywayland.protocol.river_window_management_v1.RiverOutputV1`
        """
        self._post_event(7, id)

    @RiverWindowManagerV1.event(
        Argument(ArgumentType.NewId, interface=RiverSeatV1),
    )
    def seat(self, id: RiverSeatV1) -> None:
        """New seat

        A new seat has been created.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        :param id:
        :type id:
            :class:`~pywayland.protocol.river_window_management_v1.RiverSeatV1`
        """
        self._post_event(8, id)


class RiverWindowManagerV1Global(Global):
    interface = RiverWindowManagerV1


RiverWindowManagerV1._gen_c()
RiverWindowManagerV1.proxy_class = RiverWindowManagerV1Proxy
RiverWindowManagerV1.resource_class = RiverWindowManagerV1Resource
RiverWindowManagerV1.global_class = RiverWindowManagerV1Global
