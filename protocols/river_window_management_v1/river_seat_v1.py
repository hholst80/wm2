# This file has been autogenerated by the pywayland scanner

# SPDX-FileCopyrightText: Â© 2024 Isaac Freund
# SPDX-License-Identifier: MIT
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

from __future__ import annotations

import enum

from pywayland.protocol_core import (
    Argument,
    ArgumentType,
    Global,
    Interface,
    Proxy,
    Resource,
)

from .river_pointer_binding_v1 import RiverPointerBindingV1
from .river_shell_surface_v1 import RiverShellSurfaceV1
from .river_window_v1 import RiverWindowV1


class RiverSeatV1(Interface):
    """A window management seat

    This object represents a single user's collection of input devices. It
    allows the window manager to route keyboard input to windows, get high-
    level information about pointer input, define keyboard and pointer
    bindings, etc.

    TODO:   - touch input   - tablet input
    """

    name = "river_seat_v1"
    version = 3

    class modifiers(enum.IntFlag):
        none = 0
        shift = 1
        ctrl = 4
        mod1 = 8
        mod3 = 32
        mod4 = 64
        mod5 = 128


class RiverSeatV1Proxy(Proxy[RiverSeatV1]):
    interface = RiverSeatV1

    @RiverSeatV1.request()
    def destroy(self) -> None:
        """Destroy the seat object

        This request indicates that the client will no longer use the seat
        object and that it may be safely destroyed.

        This request should be made after the :func:`RiverSeatV1.removed()`
        event is received to complete destruction of the seat.
        """
        self._marshal(0)
        self._destroy()

    @RiverSeatV1.request(
        Argument(ArgumentType.Object, interface=RiverWindowV1),
    )
    def focus_window(self, window: RiverWindowV1) -> None:
        """Give keyboard focus to a window

        Request that the compositor send keyboard input to the given window.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.

        :param window:
        :type window:
            :class:`~pywayland.protocol.river_window_management_v1.RiverWindowV1`
        """
        self._marshal(1, window)

    @RiverSeatV1.request(
        Argument(ArgumentType.Object, interface=RiverShellSurfaceV1),
    )
    def focus_shell_surface(self, shell_surface: RiverShellSurfaceV1) -> None:
        """Give keyboard focus to a shell_surface

        Request that the compositor send keyboard input to the given shell
        surface.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.

        :param shell_surface:
        :type shell_surface:
            :class:`~pywayland.protocol.river_window_management_v1.RiverShellSurfaceV1`
        """
        self._marshal(2, shell_surface)

    @RiverSeatV1.request()
    def clear_focus(self) -> None:
        """Clear keyboard focus

        Request that the compositor not send keyboard input to any client.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(3)

    @RiverSeatV1.request()
    def op_start_pointer(self) -> None:
        """Start an interactive pointer operation

        Start an interactive pointer operation. During the operation, op_delta
        events will be sent based on pointer input.

        When all pointer buttons are released, the op_release event is sent.

        The pointer operation continues until the op_end request is made during
        a manage sequence and that manage sequence is finished.

        The window manager may use this operation to implement interactive
        move/resize of windows by setting the position of windows and proposing
        dimensions based off of the op_delta events.

        This request is ignored if an operation is already in progress.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(4)

    @RiverSeatV1.request()
    def op_end(self) -> None:
        """End an interactive operation

        End an interactive operation.

        This request is ignored if there is no operation in progress.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(5)

    @RiverSeatV1.request(
        Argument(ArgumentType.NewId, interface=RiverPointerBindingV1),
        Argument(ArgumentType.Uint),
        Argument(ArgumentType.Uint),
    )
    def get_pointer_binding(self, button: int, modifiers: int) -> Proxy[RiverPointerBindingV1]:
        """Define a new pointer binding

        Define a pointer binding in terms of a pointer button, modifiers, and
        other configurable properties.

        The button argument is a Linux input event code defined in the
        linux/input-event-codes.h header file (e.g. BTN_RIGHT).

        The new pointer binding is not enabled until initial configuration is
        completed and the enable request is made during a manage sequence.

        :param button:
            a Linux input event code
        :type button:
            `ArgumentType.Uint`
        :param modifiers:
        :type modifiers:
            `ArgumentType.Uint`
        :returns:
            :class:`~pywayland.protocol.river_window_management_v1.RiverPointerBindingV1`
        """
        id = self._marshal_constructor(6, RiverPointerBindingV1, button, modifiers)
        return id

    @RiverSeatV1.request(
        Argument(ArgumentType.String),
        Argument(ArgumentType.Uint),
        version=2,
    )
    def set_xcursor_theme(self, name: str, size: int) -> None:
        """Set the xcursor theme for the seat

        Set the XCursor theme for the seat. This theme is used for cursors
        rendered by the compositor, but not necessarily for cursors rendered by
        clients.

        Note: The window manager may also wish to set the XCURSOR_THEME and
        XCURSOR_SIZE environment variable for programs it starts.

        :param name:
        :type name:
            `ArgumentType.String`
        :param size:
        :type size:
            `ArgumentType.Uint`
        """
        self._marshal(7, name, size)

    @RiverSeatV1.request(
        Argument(ArgumentType.Int),
        Argument(ArgumentType.Int),
        version=3,
    )
    def pointer_warp(self, x: int, y: int) -> None:
        """Warp the pointer to a given position

        Warp the pointer to the given position in the compositor's logical
        coordinate space.

        If the given position is outside the bounds of all outputs, the pointer
        will be warped to the closest point inside an output instead.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.

        :param x:
        :type x:
            `ArgumentType.Int`
        :param y:
        :type y:
            `ArgumentType.Int`
        """
        self._marshal(8, x, y)


class RiverSeatV1Resource(Resource):
    interface = RiverSeatV1

    @RiverSeatV1.event()
    def removed(self) -> None:
        """The seat is removed

        This event indicates that seat is no longer in use and should be
        destroyed.

        The server will send no further events on this object and ignore any
        request (other than :func:`RiverSeatV1.destroy()`) made after this
        event is sent.  The client should destroy this object with the
        :func:`RiverSeatV1.destroy()` request to free up resources.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.
        """
        self._post_event(0)

    @RiverSeatV1.event(
        Argument(ArgumentType.Uint),
    )
    def wl_seat(self, name: int) -> None:
        """Corresponding :class:`~pywayland.protocol.wayland.WlSeat`

        The :class:`~pywayland.protocol.wayland.WlSeat` object corresponding to
        the :class:`RiverSeatV1`. The argument is the global name of the
        :class:`~pywayland.protocol.wayland.WlSeat` advertised with
        :func:`WlRegistry.global()
        <pywayland.protocol.wayland.WlRegistry.global>`.

        It is guaranteed that the corresponding
        :class:`~pywayland.protocol.wayland.WlSeat` is advertised before this
        event is sent.

        This event is sent exactly once. The
        :class:`~pywayland.protocol.wayland.WlSeat` associated with a
        :class:`RiverSeatV1` cannot change. It is guaranteed that there is a
        1-to-1 mapping between :class:`~pywayland.protocol.wayland.WlSeat` and
        :class:`RiverSeatV1` objects.

        The global_remove event for the corresponding
        :class:`~pywayland.protocol.wayland.WlSeat` may be sent before the
        :func:`RiverSeatV1.remove()` event. This is due to the fact that
        :class:`RiverSeatV1` state changes are synced to the river window
        management manage sequence while changes to globals are not.

        Rationale: The window manager may want to trigger window management
        state changes based on normal input events received by its shell
        surfaces for example.

        :param name:
            name of the :class:`~pywayland.protocol.wayland.WlSeat` global
        :type name:
            `ArgumentType.Uint`
        """
        self._post_event(1, name)

    @RiverSeatV1.event(
        Argument(ArgumentType.Object, interface=RiverWindowV1),
    )
    def pointer_enter(self, window: RiverWindowV1) -> None:
        """Pointer entered a window

        The seat's pointer entered the given window's area.

        The area of a window is defined to include the area defined by the
        window dimensions, borders configured using
        :func:`RiverWindowV1.set_borders()
        <pywayland.protocol.river_window_management_v1.RiverWindowV1.set_borders>`,
        and the input regions of decoration surfaces. In particular, it does
        not include input regions of surfaces belonging to the window that
        extend outside the window dimensions.

        The pointer of a seat may only enter a single window at a time. When
        the pointer moves between windows, the pointer_leave event for the old
        window must be sent before the pointer_enter event for the new window.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        :param window:
        :type window:
            :class:`~pywayland.protocol.river_window_management_v1.RiverWindowV1`
        """
        self._post_event(2, window)

    @RiverSeatV1.event()
    def pointer_leave(self) -> None:
        """Pointer left the entered window

        The seat's pointer left the window for which pointer_enter was most
        recently sent. See pointer_enter for details.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.
        """
        self._post_event(3)

    @RiverSeatV1.event(
        Argument(ArgumentType.Object, interface=RiverWindowV1),
    )
    def window_interaction(self, window: RiverWindowV1) -> None:
        """A window has been interacted with

        A window has been interacted with beyond the pointer merely passing
        over it. This event might be sent due to a pointer button press or due
        to a touch/tablet tool interaction with the window.

        There are no guarantees regarding how this event is sent in relation to
        the pointer_enter and pointer_leave events as the interaction may use
        touch or tablet tool input.

        Rationale: this event gives window managers necessary information to
        determine when to send keyboard focus, raise a window that already has
        keyboard focus, etc. Rather than expose all pointer, touch, and tablet
        events to window managers, a policy over mechanism approach is taken.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        :param window:
        :type window:
            :class:`~pywayland.protocol.river_window_management_v1.RiverWindowV1`
        """
        self._post_event(4, window)

    @RiverSeatV1.event(
        Argument(ArgumentType.Object, interface=RiverShellSurfaceV1),
    )
    def shell_surface_interaction(self, shell_surface: RiverShellSurfaceV1) -> None:
        """A shell surface has been interacted with

        A shell surface has been interacted with beyond the pointer merely
        passing over it. This event might be sent due to a pointer button press
        or due to a touch/tablet tool interaction with the shell_surface.

        There are no guarantees regarding how this event is sent in relation to
        the pointer_enter and pointer_leave events as the interaction may use
        touch or tablet tool input.

        Rationale: While the shell surface does receive all
        :class:`~pywayland.protocol.wayland.WlPointer`,
        :class:`~pywayland.protocol.wayland.WlTouch`, etc. input events for the
        surface directly, these events do not necessarily trigger a manage
        sequence and therefore do not allow the window manager to update focus
        or perform other actions in response to the input in a race-free way.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        :param shell_surface:
        :type shell_surface:
            :class:`~pywayland.protocol.river_window_management_v1.RiverShellSurfaceV1`
        """
        self._post_event(5, shell_surface)

    @RiverSeatV1.event(
        Argument(ArgumentType.Int),
        Argument(ArgumentType.Int),
    )
    def op_delta(self, dx: int, dy: int) -> None:
        """Total cumulative motion since op start

        This event indicates the total change in position since the start of
        the operation of the pointer/touch point/etc.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        :param dx:
            total change in x
        :type dx:
            `ArgumentType.Int`
        :param dy:
            total change in y
        :type dy:
            `ArgumentType.Int`
        """
        self._post_event(6, dx, dy)

    @RiverSeatV1.event()
    def op_release(self) -> None:
        """Operation input has been released

        The input driving the current interactive operation has been released.
        For a pointer op for example, all pointer buttons have been released.

        Depending on the op type, op_delta events may continue to be sent until
        the op is ended with the op_end request.

        This event is sent at most once during an interactive operation.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.
        """
        self._post_event(7)

    @RiverSeatV1.event(
        Argument(ArgumentType.Int),
        Argument(ArgumentType.Int),
        version=2,
    )
    def pointer_position(self, x: int, y: int) -> None:
        """The current position of the pointer

        The current position of the pointer in the compositor's logical
        coordinate space.

        This state is special in that a change in pointer position alone must
        not cause the compositor to start a manage sequence.

        Assuming the seat has a pointer, this event must be sent in every
        manage sequence unless there is no change in x/y position since the
        last time this event was sent.

        :param x:
        :type x:
            `ArgumentType.Int`
        :param y:
        :type y:
            `ArgumentType.Int`
        """
        self._post_event(8, x, y)


class RiverSeatV1Global(Global):
    interface = RiverSeatV1


RiverSeatV1._gen_c()
RiverSeatV1.proxy_class = RiverSeatV1Proxy
RiverSeatV1.resource_class = RiverSeatV1Resource
RiverSeatV1.global_class = RiverSeatV1Global
