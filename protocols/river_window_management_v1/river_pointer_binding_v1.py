# This file has been autogenerated by the pywayland scanner

# SPDX-FileCopyrightText: Â© 2024 Isaac Freund
# SPDX-License-Identifier: MIT
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

from __future__ import annotations

from pywayland.protocol_core import Global, Interface, Proxy, Resource


class RiverPointerBindingV1(Interface):
    """Configure a pointer binding, receive trigger events

    This object allows the window manager to configure a pointer binding and
    receive events when the binding is triggered.

    The new pointer binding is not enabled until the enable request is made
    during a manage sequence.

    Normally, all pointer button events are sent to the surface with pointer
    focus by the compositor. Pointer button events that trigger a pointer
    binding are not sent to the surface with pointer focus.

    If multiple pointer bindings would be triggered by a single physical
    pointer event on the compositor side, it is compositor policy which pointer
    binding(s) will receive press/release events or if all of the matched
    pointer bindings receive press/release events.
    """

    name = "river_pointer_binding_v1"
    version = 3


class RiverPointerBindingV1Proxy(Proxy[RiverPointerBindingV1]):
    interface = RiverPointerBindingV1

    @RiverPointerBindingV1.request()
    def destroy(self) -> None:
        """Destroy the pointer binding object

        This request indicates that the client will no longer use the pointer
        binding object and that it may be safely destroyed.
        """
        self._marshal(0)
        self._destroy()

    @RiverPointerBindingV1.request()
    def enable(self) -> None:
        """Enable the pointer binding

        This request should be made after all initial configuration has been
        completed and the window manager wishes the pointer binding to be able
        to be triggered.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(1)

    @RiverPointerBindingV1.request()
    def disable(self) -> None:
        """Disable the pointer binding

        This request may be used to temporarily disable the pointer binding. It
        may be later re-enabled with the enable request.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(2)


class RiverPointerBindingV1Resource(Resource):
    interface = RiverPointerBindingV1

    @RiverPointerBindingV1.event()
    def pressed(self) -> None:
        """The bound pointer button has been pressed

        This event indicates that the pointer button triggering the binding has
        been pressed.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        The compositor should wait for the manage sequence to complete before
        processing further input events. This allows the window manager client
        to, for example, modify key bindings and keyboard focus without racing
        against future input events. The window manager should of course
        respond as soon as possible as the capacity of the compositor to buffer
        incoming input events is finite.
        """
        self._post_event(0)

    @RiverPointerBindingV1.event()
    def released(self) -> None:
        """The bound pointer button has been released

        This event indicates that the pointer button triggering the binding has
        been released.

        Releasing the modifiers for the binding without releasing the pointer
        button does not trigger the release event. This event is sent when the
        pointer button is released, even if the modifiers have changed since
        the pressed event.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        The compositor should wait for the manage sequence to complete before
        processing further input events. This allows the window manager client
        to, for example, modify key bindings and keyboard focus without racing
        against future input events. The window manager should of course
        respond as soon as possible as the capacity of the compositor to buffer
        incoming input events is finite.
        """
        self._post_event(1)


class RiverPointerBindingV1Global(Global):
    interface = RiverPointerBindingV1


RiverPointerBindingV1._gen_c()
RiverPointerBindingV1.proxy_class = RiverPointerBindingV1Proxy
RiverPointerBindingV1.resource_class = RiverPointerBindingV1Resource
RiverPointerBindingV1.global_class = RiverPointerBindingV1Global
