# This file has been autogenerated by the pywayland scanner

# SPDX-FileCopyrightText: Â© 2024 Isaac Freund
# SPDX-License-Identifier: MIT
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

from __future__ import annotations

import enum

from pywayland.protocol_core import (
    Argument,
    ArgumentType,
    Global,
    Interface,
    Proxy,
    Resource,
)

from ..wayland import WlSurface
from .river_decoration_v1 import RiverDecorationV1
from .river_node_v1 import RiverNodeV1
from .river_output_v1 import RiverOutputV1
# RiverSeatV1 imported lazily to break circular dependency
_RiverSeatV1 = None
def _get_RiverSeatV1():
    global _RiverSeatV1
    if _RiverSeatV1 is None:
        from .river_seat_v1 import RiverSeatV1
        _RiverSeatV1 = RiverSeatV1
    return _RiverSeatV1


class RiverWindowV1(Interface):
    """A logical window

    This represents a logical window. For example, a window may correspond to
    an xdg_toplevel or Xwayland window.

    A newly created window will not be displayed until the window manager
    proposes window dimensions with the propose_dimensions request as part of a
    manage sequence, the server replies with a dimensions event as part of a
    render sequence, and that render sequence is finished.
    """

    name = "river_window_v1"
    version = 4

    class error(enum.IntEnum):
        node_exists = 0
        invalid_dimensions = 1
        invalid_border = 2
        invalid_clip_box = 3

    class decoration_hint(enum.IntEnum):
        only_supports_csd = 0
        prefers_csd = 1
        prefers_ssd = 2
        no_preference = 3

    class edges(enum.IntFlag):
        none = 0
        top = 1
        bottom = 2
        left = 4
        right = 8

    class capabilities(enum.IntFlag):
        window_menu = 1
        maximize = 2
        fullscreen = 4
        minimize = 8


class RiverWindowV1Proxy(Proxy[RiverWindowV1]):
    interface = RiverWindowV1

    @RiverWindowV1.request()
    def destroy(self) -> None:
        """Destroy the window object

        This request indicates that the client will no longer use the window
        object and that it may be safely destroyed.

        This request should be made after the :func:`RiverWindowV1.closed()`
        event or :func:`RiverWindowManagerV1.finished()
        <pywayland.protocol.river_window_management_v1.RiverWindowManagerV1.finished>`
        is received to complete destruction of the window.
        """
        self._marshal(0)
        self._destroy()

    @RiverWindowV1.request()
    def close(self) -> None:
        """Request that the window be closed

        Request that the window be closed. The window may ignore this request
        or only close after some delay, perhaps opening a dialog asking the
        user to save their work or similar.

        The server will send a :func:`RiverWindowV1.closed()` event if/when the
        window has been closed.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(1)

    @RiverWindowV1.request(
        Argument(ArgumentType.NewId, interface=RiverNodeV1),
    )
    def get_node(self) -> Proxy[RiverNodeV1]:
        """Get the window's render list node

        Get the node in the render list corresponding to the window.

        It is a protocol error to make this request more than once for a single
        window.

        :returns:
            :class:`~pywayland.protocol.river_window_management_v1.RiverNodeV1`
        """
        id = self._marshal_constructor(2, RiverNodeV1)
        return id

    @RiverWindowV1.request(
        Argument(ArgumentType.Int),
        Argument(ArgumentType.Int),
    )
    def propose_dimensions(self, width: int, height: int) -> None:
        """Propose window dimensions

        This request proposes dimensions for the window in the compositor's
        logical coordinate space.

        The width and height must be greater than or equal to zero. If the
        width or height is zero the window will be allowed to decide its own
        dimensions.

        The window may not take the exact dimensions proposed. The actual
        dimensions taken by the window will be sent in a subsequent
        :func:`RiverWindowV1.dimensions()` event. For example, a terminal
        emulator may only allow dimensions that are multiple of the cell size.

        When a propose_dimensions request is made, the server must send a
        dimensions event in response as soon as possible. It may not be
        possible to send a dimensions event in the very next render sequence
        if, for example, the window takes too long to respond to the first
        proposed dimensions. In this case, the server will send the dimensions
        event in a future render sequence. The window will not be displayed
        until the first dimensions event is received and the render sequence is
        finished.

        Note that the dimensions of a :class:`RiverWindowV1` refer to the
        dimensions of the window content and are unaffected by the presence of
        borders or decoration surfaces.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.

        :param width:
        :type width:
            `ArgumentType.Int`
        :param height:
        :type height:
            `ArgumentType.Int`
        """
        self._marshal(3, width, height)

    @RiverWindowV1.request()
    def hide(self) -> None:
        """Request that the window be hidden

        Request that the window be hidden. Has no effect if the window is
        already hidden. Hides any window borders and decorations as well.

        Newly created windows are considered shown unless explicitly hidden
        with the hide request.

        This request modifies rendering state and may only be made as part of a
        render sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(4)

    @RiverWindowV1.request()
    def show(self) -> None:
        """Request that the window be shown

        Request that the window be shown. Has no effect if the window is not
        hidden. Does not guarantee that the window is visible as it may be
        completely obscured by other windows placed above it for example.

        Newly created windows are considered shown unless explicitly hidden
        with the hide request.

        This request modifies rendering state and may only be made as part of a
        render sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(5)

    @RiverWindowV1.request()
    def use_csd(self) -> None:
        """Tell the client to use csd

        Tell the client to use client side decoration and draw its own title
        bar, borders, etc.

        This is the default if neither this request nor the use_ssd request is
        ever made.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(6)

    @RiverWindowV1.request()
    def use_ssd(self) -> None:
        """Tell the client to use ssd

        Tell the client to use server side decoration and not draw any client
        side decorations.

        This request will have no effect if the client only supports client
        side decoration, see the decoration_hint event.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(7)

    @RiverWindowV1.request(
        Argument(ArgumentType.Uint),
        Argument(ArgumentType.Int),
        Argument(ArgumentType.Uint),
        Argument(ArgumentType.Uint),
        Argument(ArgumentType.Uint),
        Argument(ArgumentType.Uint),
    )
    def set_borders(self, edges: int, width: int, r: int, g: int, b: int, a: int) -> None:
        """Set window borders

        This request decorates the window with borders drawn by the compositor
        on the specified edges of the window. Borders are drawn above the
        window content.

        Corners are drawn only between borders on adjacent edges. If e.g. the
        left edge has a border and the top edge does not, the border drawn on
        the left edge will not extend vertically beyond the top edge of the
        window.

        Borders are not drawn while the window is fullscreen.

        The color is defined by four 32-bit RGBA values. Unless specified in
        another protocol extension, the RGBA values use pre-multiplied alpha.

        Setting the edges to none or the width to 0 disables the borders.
        Setting a negative width is a protocol error.

        This request completely overrides all previous set_borders requests.
        Only the most recent set_borders request has an effect.

        Note that the position/dimensions of a :class:`RiverWindowV1` refer to
        the position/dimensions of the window content and are unaffected by the
        presence of borders or decoration surfaces.

        This request modifies rendering state and may only be made as part of a
        render sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.

        :param edges:
        :type edges:
            `ArgumentType.Uint`
        :param width:
        :type width:
            `ArgumentType.Int`
        :param r:
        :type r:
            `ArgumentType.Uint`
        :param g:
        :type g:
            `ArgumentType.Uint`
        :param b:
        :type b:
            `ArgumentType.Uint`
        :param a:
        :type a:
            `ArgumentType.Uint`
        """
        self._marshal(8, edges, width, r, g, b, a)

    @RiverWindowV1.request(
        Argument(ArgumentType.Uint),
    )
    def set_tiled(self, edges: int) -> None:
        """Set window tiled state

        Inform the window that it is part of a tiled layout and adjacent to
        other elements in the tiled layout on the given edges.

        The window should use this information to change the style of its
        client side decorations and avoid drawing e.g. drop shadows outside of
        the window dimensions on the tiled edges.

        Setting the edges argument to none informs the window that it is not
        part of a tiled layout. If this request is never made, the window is
        informed that it is not part of a tiled layout.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.

        :param edges:
        :type edges:
            `ArgumentType.Uint`
        """
        self._marshal(9, edges)

    @RiverWindowV1.request(
        Argument(ArgumentType.NewId, interface=RiverDecorationV1),
        Argument(ArgumentType.Object, interface=WlSurface),
    )
    def get_decoration_above(self, surface: WlSurface) -> Proxy[RiverDecorationV1]:
        """Create a decoration surface above the window

        Create a decoration surface and assign the
        :class:`~pywayland.protocol.river_window_management_v1.RiverDecorationV1`
        role to the surface. The created decoration is placed above the window
        in rendering order, see the description of
        :class:`~pywayland.protocol.river_window_management_v1.RiverDecorationV1`.

        Providing a :class:`~pywayland.protocol.wayland.WlSurface` which
        already has a role or already has a buffer attached or committed is a
        protocol error.

        :param surface:
        :type surface:
            :class:`~pywayland.protocol.wayland.WlSurface`
        :returns:
            :class:`~pywayland.protocol.river_window_management_v1.RiverDecorationV1`
        """
        id = self._marshal_constructor(10, RiverDecorationV1, surface)
        return id

    @RiverWindowV1.request(
        Argument(ArgumentType.NewId, interface=RiverDecorationV1),
        Argument(ArgumentType.Object, interface=WlSurface),
    )
    def get_decoration_below(self, surface: WlSurface) -> Proxy[RiverDecorationV1]:
        """Create a decoration surface below the window

        Create a decoration surface and assign the
        :class:`~pywayland.protocol.river_window_management_v1.RiverDecorationV1`
        role to the surface. The created decoration is placed below the window
        in rendering order, see the description of
        :class:`~pywayland.protocol.river_window_management_v1.RiverDecorationV1`.

        Providing a :class:`~pywayland.protocol.wayland.WlSurface` which
        already has a role or already has a buffer attached or committed is a
        protocol error.

        :param surface:
        :type surface:
            :class:`~pywayland.protocol.wayland.WlSurface`
        :returns:
            :class:`~pywayland.protocol.river_window_management_v1.RiverDecorationV1`
        """
        id = self._marshal_constructor(11, RiverDecorationV1, surface)
        return id

    @RiverWindowV1.request()
    def inform_resize_start(self) -> None:
        """Inform the window it is being resized

        Inform the window that it is being resized. The window manager should
        use this request to inform windows that are the target of an
        interactive resize for example.

        The window manager remains responsible for handling the position and
        dimensions of the window while it is resizing.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(12)

    @RiverWindowV1.request()
    def inform_resize_end(self) -> None:
        """Inform the window it no longer being resized

        Inform the window that it is no longer being resized. The window
        manager should use this request to inform windows that are the target
        of an interactive resize that the interactive resize has ended for
        example.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(13)

    @RiverWindowV1.request(
        Argument(ArgumentType.Uint),
    )
    def set_capabilities(self, caps: int) -> None:
        """Inform window of supported capabilities

        This request informs the window of the capabilities supported by the
        window manager. If the window manager, for example, ignores requests to
        be maximized from the window it should not tell the window that it
        supports the maximize capability.

        The window might use this information to, for example, only show a
        maximize button if the window manager supports the maximize capability.

        The window manager client should use this request to set capabilities
        for all new windows. If this request is never made, the compositor will
        inform windows that all capabilities are supported.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.

        :param caps:
        :type caps:
            `ArgumentType.Uint`
        """
        self._marshal(14, caps)

    @RiverWindowV1.request()
    def inform_maximized(self) -> None:
        """Inform the window that it is maximized

        Inform the window that it is maximized. The window might use this
        information to adapt the style of its client-side window decorations
        for example.

        The window manager remains responsible for handling the position and
        dimensions of the window while it is maximized.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(15)

    @RiverWindowV1.request()
    def inform_unmaximized(self) -> None:
        """Inform the window that it is unmaximized

        Inform the window that it is unmaximized. The window might use this
        information to adapt the style of its client-side window decorations
        for example.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(16)

    @RiverWindowV1.request()
    def inform_fullscreen(self) -> None:
        """Inform the window that it is fullscreen

        Inform the window that it is fullscreen. The window might use this
        information to adapt the style of its client-side window decorations
        for example.

        This request does not affect the size/position of the window or cause
        it to become the only window rendered, see the
        :func:`RiverWindowV1.fullscreen()` and exit_fullscreen requests for
        that.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(17)

    @RiverWindowV1.request()
    def inform_not_fullscreen(self) -> None:
        """Inform the window that it is not fullscreen

        Inform the window that it is not fullscreen. The window might use this
        information to adapt the style of its client-side window decorations
        for example.

        This request does not affect the size/position of the window or cause
        it to become the only window rendered, see the
        :func:`RiverWindowV1.fullscreen()` and exit_fullscreen requests for
        that.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(18)

    @RiverWindowV1.request(
        Argument(ArgumentType.Object, interface=RiverOutputV1),
    )
    def fullscreen(self, output: RiverOutputV1) -> None:
        """Make the window fullscreen

        Make the window fullscreen on the given output. If multiple windows are
        fullscreen on the same output at the same time only the "top" window in
        rendering order shall be displayed.

        All
        :class:`~pywayland.protocol.river_window_management_v1.RiverShellSurfaceV1`
        objects above the top fullscreen window in the rendering order will
        continue to be rendered.

        The compositor will handle the position and dimensions of the window
        while it is fullscreen. The set_position and propose_dimensions
        requests shall not affect the current position and dimensions of a
        fullscreen window.

        The compositor will clip window content, decoration surfaces, and
        borders to the given output's dimensions while the window is
        fullscreen. The effects of set_clip_box and set_content_clip_box are
        ignored while the window is fullscreen.

        If the output on which a window is currently fullscreen is removed, the
        windowing state is modified as if there were an exit_fullscreen request
        made in the same manage sequence as the :func:`RiverOutputV1.removed()
        <pywayland.protocol.river_window_management_v1.RiverOutputV1.removed>`
        event.

        This request does not inform the window that it is fullscreen, see the
        :func:`RiverWindowV1.inform_fullscreen()` and inform_not_fullscreen
        requests.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.

        :param output:
        :type output:
            :class:`~pywayland.protocol.river_window_management_v1.RiverOutputV1`
        """
        self._marshal(19, output)

    @RiverWindowV1.request()
    def exit_fullscreen(self) -> None:
        """Make the window not fullscreen

        Make the window not fullscreen.

        The position and dimensions are undefined after this request is made
        until a manage sequence in which the window manager makes the
        propose_dimensions and set_position requests is completed.

        The window manager should make propose_dimensions and set_position
        requests in the same manage sequence as the exit_fullscreen request for
        frame perfection.

        This request does not inform the window that it is fullscreen, see the
        :func:`RiverWindowV1.inform_fullscreen()` and inform_not_fullscreen
        requests.

        This request modifies window management state and may only be made as
        part of a manage sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.
        """
        self._marshal(20)

    @RiverWindowV1.request(
        Argument(ArgumentType.Int),
        Argument(ArgumentType.Int),
        Argument(ArgumentType.Int),
        Argument(ArgumentType.Int),
        version=2,
    )
    def set_clip_box(self, x: int, y: int, width: int, height: int) -> None:
        """Clip the window to a given box

        Clip the window, including borders and decoration surfaces, to the box
        specified by the x, y, width, and height arguments. The x/y position of
        the box is relative to the top left corner of the window.

        The width and height arguments must be greater than or equal to 0.

        Setting a clip box with 0 width or height disables clipping.

        The clip box is ignored while the window is fullscreen.

        Both set_clip_box and set_content_clip_box may be enabled
        simultaneously.

        This request modifies rendering state and may only be made as part of a
        render sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.

        :param x:
        :type x:
            `ArgumentType.Int`
        :param y:
        :type y:
            `ArgumentType.Int`
        :param width:
        :type width:
            `ArgumentType.Int`
        :param height:
        :type height:
            `ArgumentType.Int`
        """
        self._marshal(21, x, y, width, height)

    @RiverWindowV1.request(
        Argument(ArgumentType.Int),
        Argument(ArgumentType.Int),
        Argument(ArgumentType.Int),
        Argument(ArgumentType.Int),
        version=3,
    )
    def set_content_clip_box(self, x: int, y: int, width: int, height: int) -> None:
        """Clip the window content to a given box

        Clip the content of the window, excluding borders and decoration
        surfaces, to the box specified by the x, y, width, and height
        arguments. The x/y position of the box is relative to the top left
        corner of the window.

        Borders drawn by the compositor (see set_borders) are placed around the
        intersection of the window content (as defined by the dimensions event)
        and the content clip box when content clipping is enabled.

        The width and height arguments must be greater than or equal to 0.

        Setting a box with 0 width or height disables content clipping.

        The content clip box is ignored while the window is fullscreen.

        Both set_clip_box and set_content_clip_box may be enabled
        simultaneously.

        This request modifies rendering state and may only be made as part of a
        render sequence, see the
        :class:`~pywayland.protocol.river_window_management_v1.RiverWindowManagerV1`
        description.

        :param x:
        :type x:
            `ArgumentType.Int`
        :param y:
        :type y:
            `ArgumentType.Int`
        :param width:
        :type width:
            `ArgumentType.Int`
        :param height:
        :type height:
            `ArgumentType.Int`
        """
        self._marshal(22, x, y, width, height)


class RiverWindowV1Resource(Resource):
    interface = RiverWindowV1

    @RiverWindowV1.event()
    def closed(self) -> None:
        """The window has been closed

        The window has been closed by the server, perhaps due to an
        xdg_toplevel.close request or similar.

        The server will send no further events on this object and ignore any
        request other than :func:`RiverWindowV1.destroy()` made after this
        event is sent. The client should destroy this object with the
        :func:`RiverWindowV1.destroy()` request to free up resources.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.
        """
        self._post_event(0)

    @RiverWindowV1.event(
        Argument(ArgumentType.Int),
        Argument(ArgumentType.Int),
        Argument(ArgumentType.Int),
        Argument(ArgumentType.Int),
    )
    def dimensions_hint(self, min_width: int, min_height: int, max_width: int, max_height: int) -> None:
        """The window's preferred min/max dimensions

        This event informs the window manager of the window's preferred min/max
        dimensions. These preferences are a hint, and the window manager is
        free to propose dimensions outside of these bounds.

        All min/max width/height values must be strictly greater than or equal
        to 0. A value of 0 indicates that the window has no preference for that
        value.

        The min_width/min_height must be strictly less than or equal to the
        max_width/max_height.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        :param min_width:
        :type min_width:
            `ArgumentType.Int`
        :param min_height:
        :type min_height:
            `ArgumentType.Int`
        :param max_width:
        :type max_width:
            `ArgumentType.Int`
        :param max_height:
        :type max_height:
            `ArgumentType.Int`
        """
        self._post_event(1, min_width, min_height, max_width, max_height)

    @RiverWindowV1.event(
        Argument(ArgumentType.Int),
        Argument(ArgumentType.Int),
    )
    def dimensions(self, width: int, height: int) -> None:
        """Window dimensions

        This event indicates the dimensions of the window in the compositor's
        logical coordinate space. The width and height must be strictly greater
        than zero.

        Note that the dimensions of a :class:`RiverWindowV1` refer to the
        dimensions of the window content and are unaffected by the presence of
        borders or decoration surfaces.

        This event is sent as part of a render sequence before the render_start
        event.

        It may be sent due to a propose_dimensions request in a previous manage
        sequence or because a window independently decides to change its
        dimensions.

        :param width:
        :type width:
            `ArgumentType.Int`
        :param height:
        :type height:
            `ArgumentType.Int`
        """
        self._post_event(2, width, height)

    @RiverWindowV1.event(
        Argument(ArgumentType.String, nullable=True),
    )
    def app_id(self, app_id: str | None) -> None:
        """The window set an application id

        The window set an application ID.

        The app_id argument will be null if the window has never set an
        application ID or if the window cleared its application ID. (Xwayland
        windows may do this for example, though xdg-toplevels may not.)

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        :param app_id:
        :type app_id:
            `ArgumentType.String` or `None`
        """
        self._post_event(3, app_id)

    @RiverWindowV1.event(
        Argument(ArgumentType.String, nullable=True),
    )
    def title(self, title: str | None) -> None:
        """The window set a title

        The window set a title.

        The title argument will be null if the window has never set a title or
        if the window cleared its title. (Xwayland windows may do this for
        example, though xdg-toplevels may not.)

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        :param title:
        :type title:
            `ArgumentType.String` or `None`
        """
        self._post_event(4, title)

    @RiverWindowV1.event(
        Argument(ArgumentType.Object, interface=RiverWindowV1, nullable=True),
    )
    def parent(self, parent: RiverWindowV1 | None) -> None:
        """The window set a parent

        The window set a parent window. If this event is never received or if
        the parent argument is null then the window has no parent.

        A surface with a parent set might be a dialog, file picker, or similar
        for the parent window.

        Child windows should generally be rendered directly above their parent.

        The compositor must guarantee that there are no loops in the window
        tree: a parent must not be the descendant of one of its children.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        :param parent:
        :type parent:
            :class:`RiverWindowV1` or `None`
        """
        self._post_event(5, parent)

    @RiverWindowV1.event(
        Argument(ArgumentType.Uint),
    )
    def decoration_hint(self, hint: int) -> None:
        """Supported/preferred decoration style

        Information from the window about the supported and preferred client
        side/server side decoration options.

        This event may be sent multiple times over the lifetime of the window
        if the window changes its preferences.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        :param hint:
        :type hint:
            `ArgumentType.Uint`
        """
        self._post_event(6, hint)

    @RiverWindowV1.event(
        Argument(ArgumentType.Object, interface=None),  # RiverSeatV1 set lazily
    )
    def pointer_move_requested(self, seat: RiverSeatV1) -> None:
        """Window requested interactive pointer move

        This event informs the window manager that the window has requested to
        be interactively moved using the pointer. The seat argument indicates
        the seat for the move.

        The xdg-shell protocol for example allows windows to request that an
        interactive move be started, perhaps when a client-side rendered
        titlebar is dragged.

        The window manager may use the :func:`RiverSeatV1.op_start_pointer()
        <pywayland.protocol.river_window_management_v1.RiverSeatV1.op_start_pointer>`
        request to interactively move the window or ignore this event entirely.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        :param seat:
        :type seat:
            :class:`~pywayland.protocol.river_window_management_v1.RiverSeatV1`
        """
        self._post_event(7, seat)

    @RiverWindowV1.event(
        Argument(ArgumentType.Object, interface=None),  # RiverSeatV1 set lazily
        Argument(ArgumentType.Uint),
    )
    def pointer_resize_requested(self, seat: RiverSeatV1, edges: int) -> None:
        """Window requested interactive pointer resize

        This event informs the window manager that the window has requested to
        be interactively resized using the pointer. The seat argument indicates
        the seat for the resize.

        The edges argument indicates which edges the window has requested to be
        resized from. The edges argument will never be none and will never have
        both top and bottom or both left and right edges set.

        The xdg-shell protocol for example allows windows to request that an
        interactive resize be started, perhaps when the corner of client-side
        rendered decorations is dragged.

        The window manager may use the :func:`RiverSeatV1.op_start_pointer()
        <pywayland.protocol.river_window_management_v1.RiverSeatV1.op_start_pointer>`
        request to interactively resize the window or ignore this event
        entirely.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        :param seat:
        :type seat:
            :class:`~pywayland.protocol.river_window_management_v1.RiverSeatV1`
        :param edges:
        :type edges:
            `ArgumentType.Uint`
        """
        self._post_event(8, seat, edges)

    @RiverWindowV1.event(
        Argument(ArgumentType.Int),
        Argument(ArgumentType.Int),
    )
    def show_window_menu_requested(self, x: int, y: int) -> None:
        """Window requested that the window menu be shown

        The xdg-shell protocol for example allows windows to request that a
        window menu be shown, for example when the user right clicks on client
        side window decorations.

        A window menu might include options to maximize or minimize the window.

        The window manager is free to ignore this request and decide what the
        window menu contains if it does choose to show one.

        The x and y arguments indicate where the window requested that the
        window menu be shown.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        :param x:
            x offset from top left corner
        :type x:
            `ArgumentType.Int`
        :param y:
            y offset from top left corner
        :type y:
            `ArgumentType.Int`
        """
        self._post_event(9, x, y)

    @RiverWindowV1.event()
    def maximize_requested(self) -> None:
        """The window requested to be maximized

        The xdg-shell protocol for example allows windows to request to be
        maximized.

        The window manager is free to honor this request using
        :func:`RiverWindowV1.inform_maximize()` or ignore it.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.
        """
        self._post_event(10)

    @RiverWindowV1.event()
    def unmaximize_requested(self) -> None:
        """The window requested to be unmaximized

        The xdg-shell protocol for example allows windows to request to be
        unmaximized.

        The window manager is free to honor this request using
        :func:`RiverWindowV1.inform_unmaximized()` or ignore it.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.
        """
        self._post_event(11)

    @RiverWindowV1.event(
        Argument(ArgumentType.Object, interface=RiverOutputV1, nullable=True),
    )
    def fullscreen_requested(self, output: RiverOutputV1 | None) -> None:
        """The window requested to be fullscreen

        The xdg-shell protocol for example allows windows to request that they
        be made fullscreen and allows them to provide an output preference.

        The window manager is free to honor this request using
        :func:`RiverWindowV1.fullscreen()` or ignore it.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.

        :param output:
        :type output:
            :class:`~pywayland.protocol.river_window_management_v1.RiverOutputV1` or `None`
        """
        self._post_event(12, output)

    @RiverWindowV1.event()
    def exit_fullscreen_requested(self) -> None:
        """The window requested to exit fullscreen

        The xdg-shell protocol for example allows windows to request to exit
        fullscreen.

        The window manager is free to honor this request using
        :func:`RiverWindowV1.exit_fullscreen()` or ignore it.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.
        """
        self._post_event(13)

    @RiverWindowV1.event()
    def minimize_requested(self) -> None:
        """The window requested to be minimized

        The xdg-shell protocol for example allows windows to request to be
        minimized.

        The window manager is free to ignore this request, hide the window, or
        do whatever else it chooses.

        This event will be followed by a manage_start event after all other new
        state has been sent by the server.
        """
        self._post_event(14)

    @RiverWindowV1.event(
        Argument(ArgumentType.Int),
        version=2,
    )
    def unreliable_pid(self, unreliable_pid: int) -> None:
        """Unreliable pid of the window's creator

        This event gives an unreliable PID of the process that created the
        window. Obtaining this information is inherently racy due to PID reuse.
        Therefore, this PID must not be used for anything security sensitive.

        Note also that a single process may create multiple windows, so there
        is not necessarily a 1-to-1 mapping from PID to window. Multiple
        windows may have the same PID.

        This event is sent once when the :class:`RiverWindowV1` is created and
        never sent again.

        :param unreliable_pid:
        :type unreliable_pid:
            `ArgumentType.Int`
        """
        self._post_event(15, unreliable_pid)

    @RiverWindowV1.event(
        version=4,
    )
    def activation_requested(self) -> None:
        """The window requested to be activated

        A client has requested that this window be activated, for example
        via the xdg-activation protocol.

        The window manager may use this to raise the window, focus it, or
        ignore it entirely.

        This event will be followed by a manage_start event after all other
        new state has been sent by the server.
        """
        self._post_event(16)


class RiverWindowV1Global(Global):
    interface = RiverWindowV1


RiverWindowV1._gen_c()
RiverWindowV1.proxy_class = RiverWindowV1Proxy
RiverWindowV1.resource_class = RiverWindowV1Resource
RiverWindowV1.global_class = RiverWindowV1Global
