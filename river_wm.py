#!/usr/bin/env python3
"""
wm2: A window manager for the River Wayland compositor (v0.4+).

Implements the river-window-management-v1 and river-xkb-bindings-v1 protocols
to provide 4 desktops, a floating overlay stack, and 3 layout modes
(fullscreen, max, 2-split).

License: MIT
"""

import enum
import logging
import os
import signal
import subprocess
import sys
from dataclasses import dataclass, field
from typing import Optional

from pywayland.client import Display

# Protocol bindings (generated by pywayland scanner)
_script_dir = os.path.dirname(os.path.abspath(__file__))
if _script_dir not in sys.path:
    sys.path.insert(0, _script_dir)
from protocols.river_window_management_v1 import (
    RiverWindowManagerV1,
    RiverWindowV1,
    RiverOutputV1,
    RiverSeatV1,
    RiverNodeV1,
    RiverPointerBindingV1,
)
from protocols.river_xkb_bindings_v1 import (
    RiverXkbBindingsV1,
    RiverXkbBindingV1,
)
from protocols.river_xkb_config_v1 import (
    RiverXkbConfigV1,
    RiverXkbKeymapV1,
    RiverXkbKeyboardV1,
)
from protocols.river_layer_shell_v1 import (
    RiverLayerShellV1,
)

logger = logging.getLogger("wm2")

# ---------------------------------------------------------------------------
# XKB keysym constants (from xkbcommon-keysyms.h)
# ---------------------------------------------------------------------------
XKB_KEY_1 = 0x0031
XKB_KEY_2 = 0x0032
XKB_KEY_3 = 0x0033
XKB_KEY_4 = 0x0034
XKB_KEY_q = 0x0071
XKB_KEY_w = 0x0077
XKB_KEY_e = 0x0065
XKB_KEY_r = 0x0072
XKB_KEY_f = 0x0066
XKB_KEY_m = 0x006d
XKB_KEY_s = 0x0073
XKB_KEY_j = 0x006a
XKB_KEY_k = 0x006b
XKB_KEY_l = 0x006c
XKB_KEY_h = 0x0068
XKB_KEY_n = 0x006e
XKB_KEY_p = 0x0070
XKB_KEY_o = 0x006f
XKB_KEY_c = 0x0063
XKB_KEY_d = 0x0064
XKB_KEY_g = 0x0067
XKB_KEY_r = 0x0072
XKB_KEY_t = 0x0074
XKB_KEY_Print = 0xFF61
XKB_KEY_Return = 0xFF0D
XKB_KEY_Tab = 0xFF09
XKB_KEY_space = 0x0020
XKB_KEY_comma = 0x002c
XKB_KEY_period = 0x002e

# Linux input event codes for pointer buttons
BTN_LEFT = 0x110
BTN_RIGHT = 0x111

# Modifier bitmask (from river_seat_v1.modifiers enum)
MOD_NONE = 0
MOD_SHIFT = 1
MOD_CTRL = 4
MOD_ALT = 8   # mod1
MOD_SUPER = 64  # mod4

# Window border edges bitmask
EDGE_NONE = 0
EDGE_TOP = 1
EDGE_BOTTOM = 2
EDGE_LEFT = 4
EDGE_RIGHT = 8
EDGE_ALL = EDGE_TOP | EDGE_BOTTOM | EDGE_LEFT | EDGE_RIGHT

# Border styling
BORDER_WIDTH = 2
BORDER_COLOR_FOCUSED = (0x5294e2ff >> 24, (0x5294e2ff >> 16) & 0xFF, (0x5294e2ff >> 8) & 0xFF, 0x5294e2ff & 0xFF)
BORDER_COLOR_UNFOCUSED = (0x404552ff >> 24, (0x404552ff >> 16) & 0xFF, (0x404552ff >> 8) & 0xFF, 0x404552ff & 0xFF)

# Recompute as 32-bit RGBA components for set_borders
BORDER_FOCUSED_R = 0x52
BORDER_FOCUSED_G = 0x94
BORDER_FOCUSED_B = 0xE2
BORDER_FOCUSED_A = 0xFF
BORDER_UNFOCUSED_R = 0x40
BORDER_UNFOCUSED_G = 0x45
BORDER_UNFOCUSED_B = 0x52
BORDER_UNFOCUSED_A = 0xFF


class LayoutMode(enum.Enum):
    FULLSCREEN = "fullscreen"
    MAX = "max"
    SPLIT = "split"


class Side(enum.Enum):
    LEFT = "left"
    RIGHT = "right"


# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------
@dataclass
class Config:
    """Runtime configuration with sensible defaults."""
    terminal_cmd: str = "foot"
    launcher_cmd: str = "fuzzel"
    border_width: int = BORDER_WIDTH
    default_layout: LayoutMode = LayoutMode.MAX
    bar_height: int = 0  # logical pixels reserved for top bar (auto-detected if 0)
    xkb_layout: str = ""    # [xkb] layout (e.g. "us"), empty = don't touch
    xkb_model: str = ""     # [xkb] model (e.g. "pc105"), empty = don't touch
    xkb_variant: str = ""   # [xkb] variant (e.g. "dvorak"), empty = don't touch
    xkb_options: str = ""   # [xkb] options (e.g. "ctrl:nocaps"), empty = don't touch

    @classmethod
    def load(cls, path: Optional[str] = None) -> "Config":
        """Load config from a TOML file, falling back to defaults."""
        cfg = cls()
        if path is None:
            xdg = os.environ.get("XDG_CONFIG_HOME", os.path.expanduser("~/.config"))
            path = os.path.join(xdg, "wm2", "config.toml")
        if os.path.isfile(path):
            try:
                import tomllib
            except ImportError:
                try:
                    import tomli as tomllib
                except ImportError:
                    logger.warning("No TOML parser available; using defaults")
                    return cfg
            try:
                with open(path, "rb") as f:
                    data = tomllib.load(f)
                cfg.terminal_cmd = data.get("terminal", cfg.terminal_cmd)
                cfg.launcher_cmd = data.get("launcher", cfg.launcher_cmd)
                cfg.border_width = data.get("border_width", cfg.border_width)
                cfg.bar_height = data.get("bar_height", cfg.bar_height)
                xkb = data.get("xkb", {})
                cfg.xkb_layout = xkb.get("layout", cfg.xkb_layout)
                cfg.xkb_model = xkb.get("model", cfg.xkb_model)
                cfg.xkb_variant = xkb.get("variant", cfg.xkb_variant)
                cfg.xkb_options = xkb.get("options", cfg.xkb_options)
                layout_str = data.get("default_layout", cfg.default_layout.value)
                cfg.default_layout = LayoutMode(layout_str)
                logger.info("Loaded config from %s", path)
            except Exception as e:
                logger.warning("Failed to load config from %s: %s", path, e)
        if cfg.bar_height == 0:
            cfg.bar_height = cls._detect_bar_height()
        return cfg

    @staticmethod
    def _detect_bar_height() -> int:
        """Auto-detect waybar height from its config and display scale."""
        import json, re
        bar_px = 0
        scale = 1.0
        # Read waybar config (jsonc)
        for path in [
            os.path.expanduser("~/.var/app/sh.ironforge.waybar/config/waybar/config"),
            os.path.expanduser("~/.config/waybar/config"),
        ]:
            try:
                with open(path) as f:
                    text = re.sub(r'//.*', '', f.read())  # strip jsonc comments
                    text = re.sub(r',\s*([}\]])', r'\1', text)  # strip trailing commas
                    data = json.loads(text)
                    bar_px = data.get("height", 0)
                    break
            except Exception:
                continue
        if bar_px == 0:
            return 0
        # Get display scale from wlr-randr
        try:
            out = subprocess.check_output(["wlr-randr"], stderr=subprocess.DEVNULL, text=True)
            for line in out.splitlines():
                if "Scale:" in line:
                    scale = float(line.split("Scale:")[1].strip())
                    break
        except Exception:
            pass
        height = int(bar_px / scale) if scale > 0 else bar_px
        logger.info("Auto-detected bar height: %dpx / scale %.1f = %d logical px", bar_px, scale, height)
        return height


# ---------------------------------------------------------------------------
# Window wrapper
# ---------------------------------------------------------------------------
@dataclass
class WindowState:
    """Tracks state for a single window managed by the WM."""
    proxy: object  # RiverWindowV1 proxy
    node: object = None  # RiverNodeV1 proxy
    app_id: Optional[str] = None
    title: Optional[str] = None
    width: int = 0
    height: int = 0
    min_width: int = 0
    min_height: int = 0
    max_width: int = 0
    max_height: int = 0
    parent: Optional["WindowState"] = None
    desktop_id: int = 1  # 1-4 or 0 for floating overlay
    side: Side = Side.LEFT  # only meaningful in split mode
    is_fullscreen: bool = False
    pending_initial_dimensions: bool = True
    closed: bool = False
    # For interactive move/resize
    move_start_x: int = 0
    move_start_y: int = 0
    pos_x: int = 0
    pos_y: int = 0


# ---------------------------------------------------------------------------
# Desktop
# ---------------------------------------------------------------------------
@dataclass
class Desktop:
    """Represents one of the 4 desktops."""
    id: int
    layout: LayoutMode = LayoutMode.MAX
    windows: list = field(default_factory=list)  # ordered stack, [0] = top
    focused_index: int = 0
    # 2-split mode state
    left_stack: list = field(default_factory=list)   # ordered, [0] = top
    right_stack: list = field(default_factory=list)
    focused_side: Side = Side.LEFT

    def all_windows(self) -> list:
        """Return all windows on this desktop."""
        if self.layout == LayoutMode.SPLIT:
            return self.left_stack + self.right_stack
        return list(self.windows)

    def add_window(self, win: WindowState):
        """Add a window to the top of the appropriate stack."""
        if self.layout == LayoutMode.SPLIT:
            if self.focused_side == Side.LEFT:
                self.left_stack.insert(0, win)
                win.side = Side.LEFT
            else:
                self.right_stack.insert(0, win)
                win.side = Side.RIGHT
        else:
            self.windows.insert(0, win)
            self.focused_index = 0

    def remove_window(self, win: WindowState):
        """Remove a window from whatever stack it's in."""
        if win in self.windows:
            self.windows.remove(win)
            if self.focused_index >= len(self.windows) and self.windows:
                self.focused_index = len(self.windows) - 1
        if win in self.left_stack:
            self.left_stack.remove(win)
        if win in self.right_stack:
            self.right_stack.remove(win)

    def get_focused_window(self) -> Optional[WindowState]:
        """Return the currently focused window on this desktop."""
        if self.layout == LayoutMode.SPLIT:
            stack = self.left_stack if self.focused_side == Side.LEFT else self.right_stack
            return stack[0] if stack else None
        if self.windows:
            idx = max(0, min(self.focused_index, len(self.windows) - 1))
            return self.windows[idx]
        return None

    def ensure_window_in_split_stacks(self, win: WindowState):
        """Ensure a window is in the correct split stack based on its side."""
        if win in self.left_stack:
            self.left_stack.remove(win)
        if win in self.right_stack:
            self.right_stack.remove(win)
        if win.side == Side.LEFT:
            self.left_stack.insert(0, win)
        else:
            self.right_stack.insert(0, win)

    def migrate_to_split(self):
        """When switching to split mode, distribute windows to left/right."""
        all_wins = list(self.windows)
        self.left_stack.clear()
        self.right_stack.clear()
        for i, w in enumerate(all_wins):
            if i % 2 == 0:
                self.left_stack.append(w)
                w.side = Side.LEFT
            else:
                self.right_stack.append(w)
                w.side = Side.RIGHT
        self.focused_side = Side.LEFT

    def migrate_from_split(self):
        """When switching from split mode, merge stacks into windows list."""
        self.windows = list(self.left_stack) + list(self.right_stack)
        self.focused_index = 0


# ---------------------------------------------------------------------------
# Output wrapper
# ---------------------------------------------------------------------------
@dataclass
class OutputState:
    """Tracks state for a logical output (monitor)."""
    proxy: object  # RiverOutputV1 proxy
    x: int = 0
    y: int = 0
    width: int = 0
    height: int = 0
    removed: bool = False
    # Non-exclusive area from layer shell (usable area after bars etc.)
    nea_x: Optional[int] = None
    nea_y: Optional[int] = None
    nea_w: Optional[int] = None
    nea_h: Optional[int] = None
    layer_shell_output: object = None  # RiverLayerShellOutputV1 proxy


# ---------------------------------------------------------------------------
# Seat wrapper
# ---------------------------------------------------------------------------
@dataclass
class SeatState:
    """Tracks state for an input seat."""
    proxy: object  # RiverSeatV1 proxy
    pointer_x: int = 0
    pointer_y: int = 0
    pointer_entered_window: Optional[WindowState] = None
    op_active: bool = False
    op_dx: int = 0
    op_dy: int = 0
    op_released: bool = False
    op_window: Optional[WindowState] = None
    op_mode: str = ""  # "move" or "resize"


# ---------------------------------------------------------------------------
# Main Window Manager
# ---------------------------------------------------------------------------
class RiverWM:
    """
    The main window manager implementing the river-window-management-v1
    protocol for the River Wayland compositor.
    """

    def __init__(self, config: Config):
        self.config = config
        self.display: Optional[Display] = None
        self.registry = None

        # Protocol globals
        self.wm_proxy = None  # RiverWindowManagerV1 proxy
        self.xkb_bindings_proxy = None  # RiverXkbBindingsV1 proxy
        self.layer_shell_proxy = None  # RiverLayerShellV1 proxy
        self.xkb_config_proxy = None   # RiverXkbConfigV1 proxy
        self.xkb_keymap_obj = None     # RiverXkbKeymapV1 (after success)
        self.xkb_keyboards: list = []  # RiverXkbKeyboardV1 objects

        # State
        self.windows: dict = {}  # proxy id -> WindowState
        self.outputs: list = []  # list of OutputState
        self.seats: list = []    # list of SeatState
        self.desktops: dict = {i: Desktop(id=i, layout=config.default_layout) for i in range(1, 5)}
        self.floating_stack: list = []  # WindowState list, [0] = top

        self.current_desktop_id: int = 1
        self.floating_active: bool = False

        # Protocol sequence state
        self.in_manage: bool = False
        self.in_render: bool = False
        self.needs_layout: bool = True
        self.pending_new_windows: list = []
        self.pending_bindings_to_enable: list = []

        # Keybinding registry
        self.key_bindings: dict = {}  # binding_proxy -> callback
        self.pointer_bindings: dict = {}  # binding_proxy -> (callback_press, callback_release)

        # Interactive operation tracking
        self.active_op_seat: Optional[SeatState] = None

        self.running = True

    @property
    def current_desktop(self) -> Desktop:
        return self.desktops[self.current_desktop_id]

    @property
    def primary_output(self) -> Optional[OutputState]:
        for o in self.outputs:
            if not o.removed:
                return o
        return None

    def _usable_area(self, output: OutputState):
        """Return (x, y, w, h) of the usable area for windows on this output."""
        if output.nea_x is not None:
            return output.nea_x, output.nea_y, output.nea_w, output.nea_h
        bar_h = self.config.bar_height
        return output.x, output.y + bar_h, output.width, output.height - bar_h

    # -------------------------------------------------------------------
    # Connection & registry
    # -------------------------------------------------------------------
    def connect(self):
        """Connect to the Wayland display and bind protocol globals."""
        self.display = Display()
        self.display.connect()
        logger.info("Connected to Wayland display")

        self.registry = self.display.get_registry()
        self.registry.dispatcher["global"] = self._on_global
        self.display.roundtrip()

        if self.wm_proxy is None:
            logger.error("river_window_manager_v1 global not found. Is River running?")
            sys.exit(1)
        if self.xkb_bindings_proxy is None:
            logger.error("river_xkb_bindings_v1 global not found.")
            sys.exit(1)

        logger.info("Bound protocol globals successfully")

    def _on_global(self, registry, id_num, iface_name, version):
        """Handle wl_registry.global events to bind our protocol interfaces."""
        if iface_name == "river_window_manager_v1":
            self.wm_proxy = registry.bind(id_num, RiverWindowManagerV1, min(version, 3))
            self._setup_wm_events()
        elif iface_name == "river_xkb_bindings_v1":
            self.xkb_bindings_proxy = registry.bind(id_num, RiverXkbBindingsV1, min(version, 2))
        elif iface_name == "river_xkb_config_v1":
            self.xkb_config_proxy = registry.bind(id_num, RiverXkbConfigV1, min(version, 1))
            self.xkb_config_proxy.dispatcher["xkb_keyboard"] = self._on_xkb_keyboard
            logger.info("Bound river_xkb_config_v1 — runtime keymap control enabled")
        elif iface_name == "river_layer_shell_v1":
            self.layer_shell_proxy = registry.bind(id_num, RiverLayerShellV1, min(version, 1))
            logger.info("Bound river_layer_shell_v1 — layer surfaces enabled")

    # -------------------------------------------------------------------
    # WM event handlers
    # -------------------------------------------------------------------
    def _setup_wm_events(self):
        """Register event handlers on the window manager proxy."""
        self.wm_proxy.dispatcher["unavailable"] = self._on_unavailable
        self.wm_proxy.dispatcher["finished"] = self._on_finished
        self.wm_proxy.dispatcher["manage_start"] = self._on_manage_start
        self.wm_proxy.dispatcher["render_start"] = self._on_render_start
        self.wm_proxy.dispatcher["window"] = self._on_window
        self.wm_proxy.dispatcher["output"] = self._on_output
        self.wm_proxy.dispatcher["seat"] = self._on_seat
        self.wm_proxy.dispatcher["session_locked"] = self._on_session_locked
        self.wm_proxy.dispatcher["session_unlocked"] = self._on_session_unlocked

    def _on_unavailable(self, proxy):
        logger.error("Window management unavailable (another WM running?)")
        self.running = False

    def _on_finished(self, proxy):
        logger.info("Server finished with window manager")
        self.running = False

    def _on_session_locked(self, proxy):
        logger.info("Session locked")

    def _on_session_unlocked(self, proxy):
        logger.info("Session unlocked")

    # -------------------------------------------------------------------
    # Window events
    # -------------------------------------------------------------------
    def _on_window(self, wm_proxy, window_proxy):
        """A new window has been created."""
        win = WindowState(proxy=window_proxy)
        self.windows[id(window_proxy)] = win

        # Get the render node for this window
        node_proxy = window_proxy.get_node()
        win.node = node_proxy

        # Register window event handlers
        window_proxy.dispatcher["closed"] = lambda p: self._on_window_closed(win)
        window_proxy.dispatcher["dimensions"] = lambda p, w, h: self._on_window_dimensions(win, w, h)
        window_proxy.dispatcher["dimensions_hint"] = lambda p, minw, minh, maxw, maxh: self._on_window_dimensions_hint(win, minw, minh, maxw, maxh)
        window_proxy.dispatcher["app_id"] = lambda p, aid: self._on_window_app_id(win, aid)
        window_proxy.dispatcher["title"] = lambda p, t: self._on_window_title(win, t)
        window_proxy.dispatcher["parent"] = lambda p, parent: self._on_window_parent(win, parent)
        window_proxy.dispatcher["decoration_hint"] = lambda p, hint: None  # ignore
        window_proxy.dispatcher["pointer_move_requested"] = lambda p, seat: self._on_pointer_move_requested(win, seat)
        window_proxy.dispatcher["pointer_resize_requested"] = lambda p, seat, edges: self._on_pointer_resize_requested(win, seat, edges)
        window_proxy.dispatcher["maximize_requested"] = lambda p: None
        window_proxy.dispatcher["unmaximize_requested"] = lambda p: None
        window_proxy.dispatcher["fullscreen_requested"] = lambda p, output: None
        window_proxy.dispatcher["exit_fullscreen_requested"] = lambda p: None
        window_proxy.dispatcher["minimize_requested"] = lambda p: None
        window_proxy.dispatcher["show_window_menu_requested"] = lambda p, x, y: None

        self.pending_new_windows.append(win)
        logger.info("New window created: %s", id(window_proxy))

    def _on_window_closed(self, win: WindowState):
        """Window has been closed by the server."""
        win.closed = True
        logger.info("Window closed: app_id=%s title=%s", win.app_id, win.title)

    def _on_window_dimensions(self, win: WindowState, width: int, height: int):
        """Window dimensions event (render sequence)."""
        win.width = width
        win.height = height
        win.pending_initial_dimensions = False
        self.needs_layout = True

    def _on_window_dimensions_hint(self, win: WindowState, min_w, min_h, max_w, max_h):
        win.min_width = min_w
        win.min_height = min_h
        win.max_width = max_w
        win.max_height = max_h

    def _on_window_app_id(self, win: WindowState, app_id):
        win.app_id = app_id

    def _on_window_title(self, win: WindowState, title):
        win.title = title

    def _on_window_parent(self, win: WindowState, parent_proxy):
        if parent_proxy is not None:
            parent_win = self.windows.get(id(parent_proxy))
            win.parent = parent_win
        else:
            win.parent = None

    def _on_pointer_move_requested(self, win: WindowState, seat_proxy):
        """Window requested interactive pointer move."""
        seat = self._find_seat(seat_proxy)
        if seat and self.in_manage:
            self._start_interactive_move(seat, win)

    def _on_pointer_resize_requested(self, win: WindowState, seat_proxy, edges):
        """Window requested interactive pointer resize."""
        seat = self._find_seat(seat_proxy)
        if seat and self.in_manage:
            self._start_interactive_resize(seat, win)

    # -------------------------------------------------------------------
    # Output events
    # -------------------------------------------------------------------
    def _on_output(self, wm_proxy, output_proxy):
        """A new output has been created."""
        out = OutputState(proxy=output_proxy)
        self.outputs.append(out)

        output_proxy.dispatcher["removed"] = lambda p: self._on_output_removed(out)
        output_proxy.dispatcher["position"] = lambda p, x, y: self._on_output_position(out, x, y)
        output_proxy.dispatcher["dimensions"] = lambda p, w, h: self._on_output_dimensions(out, w, h)
        output_proxy.dispatcher["wl_output"] = lambda p, name: None

        # Bind layer shell output for non_exclusive_area events
        if self.layer_shell_proxy is not None:
            ls_out = self.layer_shell_proxy.get_output(output_proxy)
            out.layer_shell_output = ls_out
            ls_out.dispatcher["non_exclusive_area"] = (
                lambda p, x, y, w, h: self._on_non_exclusive_area(out, x, y, w, h)
            )
            ls_out.set_default()

        logger.info("New output created")

    def _on_output_removed(self, out: OutputState):
        out.removed = True
        logger.info("Output removed")

    def _on_output_position(self, out: OutputState, x: int, y: int):
        out.x = x
        out.y = y
        self.needs_layout = True

    def _on_output_dimensions(self, out: OutputState, width: int, height: int):
        out.width = width
        out.height = height
        self.needs_layout = True
        logger.info("Output dimensions: %dx%d at (%d,%d)", width, height, out.x, out.y)

    def _on_non_exclusive_area(self, out: OutputState, x: int, y: int, w: int, h: int):
        out.nea_x = x
        out.nea_y = y
        out.nea_w = w
        out.nea_h = h
        self.needs_layout = True
        logger.info("Non-exclusive area: %d,%d %dx%d", x, y, w, h)

    # -------------------------------------------------------------------
    # Seat events
    # -------------------------------------------------------------------
    def _on_seat(self, wm_proxy, seat_proxy):
        """A new seat has been created."""
        seat = SeatState(proxy=seat_proxy)
        self.seats.append(seat)

        seat_proxy.dispatcher["removed"] = lambda p: self._on_seat_removed(seat)
        seat_proxy.dispatcher["pointer_enter"] = lambda p, win: self._on_pointer_enter(seat, win)
        seat_proxy.dispatcher["pointer_leave"] = lambda p: self._on_pointer_leave(seat)
        seat_proxy.dispatcher["window_interaction"] = lambda p, win: self._on_window_interaction(seat, win)
        seat_proxy.dispatcher["shell_surface_interaction"] = lambda p, ss: None
        seat_proxy.dispatcher["op_delta"] = lambda p, dx, dy: self._on_op_delta(seat, dx, dy)
        seat_proxy.dispatcher["op_release"] = lambda p: self._on_op_release(seat)
        seat_proxy.dispatcher["pointer_position"] = lambda p, x, y: self._on_pointer_position(seat, x, y)
        seat_proxy.dispatcher["wl_seat"] = lambda p, name: None

        logger.info("New seat created")

    def _on_seat_removed(self, seat: SeatState):
        if seat in self.seats:
            self.seats.remove(seat)
        logger.info("Seat removed")

    def _on_pointer_enter(self, seat: SeatState, window_proxy):
        win = self.windows.get(id(window_proxy))
        seat.pointer_entered_window = win

    def _on_pointer_leave(self, seat: SeatState):
        seat.pointer_entered_window = None

    def _on_window_interaction(self, seat: SeatState, window_proxy):
        """User interacted with a window — focus it."""
        win = self.windows.get(id(window_proxy))
        if win and not win.closed:
            self._focus_window(seat, win)

    def _on_pointer_position(self, seat: SeatState, x: int, y: int):
        seat.pointer_x = x
        seat.pointer_y = y

    def _on_op_delta(self, seat: SeatState, dx: int, dy: int):
        seat.op_dx = dx
        seat.op_dy = dy

    def _on_op_release(self, seat: SeatState):
        seat.op_released = True

    # -------------------------------------------------------------------
    # Manage / Render sequence handling
    # -------------------------------------------------------------------
    def _on_manage_start(self, proxy):
        """Handle manage_start event — apply window management state changes."""
        logger.debug(">>> manage_start (windows=%d)", len(self.windows))
        self.in_manage = True
        self.in_render = False

        # Process closed windows
        closed = [w for w in self.windows.values() if w.closed]
        for win in closed:
            logger.info("Removing closed window: %s (proxy=%s)", win.app_id, id(win.proxy))
            self._remove_window(win)
            win.proxy.destroy()
            del self.windows[id(win.proxy)]
            logger.info("Window removed successfully")

        # Place new windows
        for win in self.pending_new_windows:
            if not win.closed:
                self._place_new_window(win)
        self.pending_new_windows.clear()

        # Enable pending bindings
        for binding in self.pending_bindings_to_enable:
            binding.enable()
        self.pending_bindings_to_enable.clear()

        # Handle interactive operations
        for seat in self.seats:
            if seat.op_active and seat.op_window:
                self._handle_interactive_op(seat)

        # Apply window management state (focus, fullscreen, dimensions)
        self._apply_manage_state()

        # Finish manage sequence
        self.wm_proxy.manage_finish()
        self.in_manage = False
        logger.debug("<<< manage_finish")

    def _on_render_start(self, proxy):
        """Handle render_start event — apply rendering state changes."""
        logger.debug(">>> render_start")
        self.in_render = True
        self.in_manage = False

        # Apply layout (positions, visibility, z-order, borders)
        self._apply_render_state()

        # Finish render sequence
        self.wm_proxy.render_finish()
        self.in_render = False
        logger.debug("<<< render_finish")

    # -------------------------------------------------------------------
    # Window placement
    # -------------------------------------------------------------------
    def _place_new_window(self, win: WindowState):
        """Place a newly created window on the appropriate desktop/stack."""
        output = self.primary_output
        if output is None:
            return

        if self.floating_active:
            # Place in floating overlay
            win.desktop_id = 0
            self.floating_stack.insert(0, win)
            # Center on output
            win.pos_x = output.x + output.width // 4
            win.pos_y = output.y + output.height // 4
            logger.info("Placed window in floating overlay")
        else:
            desktop = self.current_desktop
            win.desktop_id = self.current_desktop_id
            desktop.add_window(win)
            logger.info("Placed window on desktop %d", self.current_desktop_id)

        # Propose initial dimensions
        self._propose_window_dimensions(win)

    def _propose_window_dimensions(self, win: WindowState):
        """Propose dimensions for a window based on its context."""
        output = self.primary_output
        if output is None:
            return

        if win.desktop_id == 0:
            # Floating: half output size
            w = output.width // 2
            h = output.height // 2
            win.proxy.propose_dimensions(w, h)
            return

        desktop = self.desktops[win.desktop_id]

        if desktop.layout == LayoutMode.FULLSCREEN:
            # Fullscreen: compositor handles dimensions
            win.proxy.propose_dimensions(output.width, output.height)
        elif desktop.layout == LayoutMode.MAX:
            win.proxy.propose_dimensions(output.width, output.height)
        elif desktop.layout == LayoutMode.SPLIT:
            ua_x, ua_y, ua_w, ua_h = self._usable_area(output)
            win.proxy.propose_dimensions(ua_w // 2, ua_h)

    def _remove_window(self, win: WindowState):
        """Remove a window from all tracking structures."""
        if win.desktop_id == 0:
            if win in self.floating_stack:
                self.floating_stack.remove(win)
        else:
            desktop = self.desktops.get(win.desktop_id)
            if desktop:
                desktop.remove_window(win)

    # -------------------------------------------------------------------
    # Focus management
    # -------------------------------------------------------------------
    def _focus_window(self, seat: SeatState, win: WindowState):
        """Set focus to a specific window."""
        if win is None or win.closed:
            return

        # If the window is on a different desktop, switch to it
        if win.desktop_id != 0 and win.desktop_id != self.current_desktop_id:
            self._switch_desktop(win.desktop_id)
        elif win.desktop_id == 0 and not self.floating_active:
            self.floating_active = True

        # Update desktop focus tracking
        if win.desktop_id == 0:
            if win in self.floating_stack:
                self.floating_stack.remove(win)
                self.floating_stack.insert(0, win)
        else:
            desktop = self.desktops[win.desktop_id]
            if desktop.layout == LayoutMode.SPLIT:
                if win in desktop.left_stack:
                    desktop.focused_side = Side.LEFT
                    idx = desktop.left_stack.index(win)
                    if idx > 0:
                        desktop.left_stack.remove(win)
                        desktop.left_stack.insert(0, win)
                elif win in desktop.right_stack:
                    desktop.focused_side = Side.RIGHT
                    idx = desktop.right_stack.index(win)
                    if idx > 0:
                        desktop.right_stack.remove(win)
                        desktop.right_stack.insert(0, win)
            else:
                if win in desktop.windows:
                    desktop.focused_index = desktop.windows.index(win)

        if self.in_manage:
            seat.proxy.focus_window(win.proxy)

    def _get_focused_window(self) -> Optional[WindowState]:
        """Get the currently focused window."""
        if self.floating_active and self.floating_stack:
            return self.floating_stack[0]
        return self.current_desktop.get_focused_window()

    # -------------------------------------------------------------------
    # Desktop switching
    # -------------------------------------------------------------------
    def _switch_desktop(self, desktop_id: int):
        """Switch to a different desktop."""
        if desktop_id < 1 or desktop_id > 4:
            return
        self.floating_active = False
        self.current_desktop_id = desktop_id
        self.needs_layout = True
        logger.info("Switched to desktop %d", desktop_id)

    def _move_window_to_desktop(self, win: WindowState, target_desktop_id: int):
        """Move a window to a different desktop."""
        if win is None or win.closed:
            return
        if target_desktop_id < 0 or target_desktop_id > 4:
            return

        # Remove from current location
        self._remove_window(win)

        if target_desktop_id == 0:
            # Move to floating overlay
            win.desktop_id = 0
            output = self.primary_output
            if output:
                win.pos_x = output.x + output.width // 4
                win.pos_y = output.y + output.height // 4
            self.floating_stack.insert(0, win)
        else:
            win.desktop_id = target_desktop_id
            self.desktops[target_desktop_id].add_window(win)

        self.needs_layout = True

    # -------------------------------------------------------------------
    # Layout mode switching
    # -------------------------------------------------------------------
    def _set_layout_mode(self, mode: LayoutMode):
        """Switch the current desktop's layout mode."""
        desktop = self.current_desktop
        old_mode = desktop.layout

        if old_mode == mode:
            return

        # Handle fullscreen exit
        if old_mode == LayoutMode.FULLSCREEN:
            for win in desktop.windows:
                if win.is_fullscreen:
                    win.proxy.exit_fullscreen()
                    win.proxy.inform_not_fullscreen()
                    win.is_fullscreen = False

        # Migrate window stacks
        if old_mode == LayoutMode.SPLIT and mode != LayoutMode.SPLIT:
            desktop.migrate_from_split()
        elif old_mode != LayoutMode.SPLIT and mode == LayoutMode.SPLIT:
            desktop.migrate_to_split()

        desktop.layout = mode
        self.needs_layout = True
        # NOTE: Do NOT call propose_dimensions here — it is a manage-sequence-only
        # request.  _apply_manage_state will propose correct dimensions when the
        # next manage sequence runs (triggered by manage_dirty in the caller).

        logger.info("Desktop %d layout changed to %s", desktop.id, mode.value)

    # -------------------------------------------------------------------
    # Apply manage state
    # -------------------------------------------------------------------
    def _apply_manage_state(self):
        """Apply window management state during a manage sequence."""
        output = self.primary_output
        if output is None:
            return

        seat = self.seats[0] if self.seats else None

        # Determine the focused window
        focused = self._get_focused_window()

        # Apply fullscreen state for current desktop
        desktop = self.current_desktop
        if desktop.layout == LayoutMode.FULLSCREEN:
            for win in desktop.windows:
                if not win.closed:
                    if win == focused:
                        if not win.is_fullscreen:
                            win.proxy.fullscreen(output.proxy)
                            win.proxy.inform_fullscreen()
                            win.is_fullscreen = True
                    else:
                        if win.is_fullscreen:
                            win.proxy.exit_fullscreen()
                            win.proxy.inform_not_fullscreen()
                            win.is_fullscreen = False
        else:
            # Ensure no windows are fullscreen in non-fullscreen modes
            for win in desktop.all_windows():
                if not win.closed and win.is_fullscreen:
                    win.proxy.exit_fullscreen()
                    win.proxy.inform_not_fullscreen()
                    win.is_fullscreen = False

        # Propose dimensions for visible windows
        ua_x, ua_y, ua_w, ua_h = self._usable_area(output)
        if desktop.layout == LayoutMode.MAX:
            for win in desktop.windows:
                if not win.closed:
                    win.proxy.propose_dimensions(ua_w, ua_h)
        elif desktop.layout == LayoutMode.SPLIT:
            half_w = ua_w // 2
            left_visible = self._visible_top(desktop.left_stack)
            right_visible = self._visible_top(desktop.right_stack)
            if left_visible and right_visible:
                left_visible.proxy.propose_dimensions(half_w, ua_h)
                right_visible.proxy.propose_dimensions(half_w, ua_h)
            elif left_visible:
                left_visible.proxy.propose_dimensions(ua_w, ua_h)
            elif right_visible:
                right_visible.proxy.propose_dimensions(ua_w, ua_h)

        # Set focus
        if seat and focused and not focused.closed:
            seat.proxy.focus_window(focused.proxy)
        elif seat:
            seat.proxy.clear_focus()

    # -------------------------------------------------------------------
    # Apply render state
    # -------------------------------------------------------------------
    def _apply_render_state(self):
        """Apply rendering state during a render sequence."""
        output = self.primary_output
        if output is None:
            return

        focused = self._get_focused_window()

        # First: hide all windows on non-current desktops
        for did, desktop in self.desktops.items():
            if did != self.current_desktop_id:
                for win in desktop.all_windows():
                    if not win.closed and win.node:
                        win.proxy.hide()

        # Current desktop
        desktop = self.current_desktop
        self._layout_desktop(desktop, output, focused)

        # Floating overlay
        if self.floating_active:
            self._layout_floating(output, focused)
        else:
            for win in self.floating_stack:
                if not win.closed and win.node:
                    win.proxy.hide()

    def _layout_desktop(self, desktop: Desktop, output: OutputState, focused: Optional[WindowState]):
        """Layout windows on the current desktop."""
        if desktop.layout == LayoutMode.FULLSCREEN:
            self._layout_fullscreen(desktop, output, focused)
        elif desktop.layout == LayoutMode.MAX:
            self._layout_max(desktop, output, focused)
        elif desktop.layout == LayoutMode.SPLIT:
            self._layout_split(desktop, output, focused)

    def _layout_fullscreen(self, desktop: Desktop, output: OutputState, focused: Optional[WindowState]):
        """Fullscreen layout: focused window is fullscreen, others hidden."""
        for win in desktop.windows:
            if win.closed:
                continue
            if win == focused:
                win.proxy.show()
                if win.node:
                    win.node.place_top()
            else:
                win.proxy.hide()

    def _layout_max(self, desktop: Desktop, output: OutputState, focused: Optional[WindowState]):
        """Max/monocle layout: one window visible at a time."""
        ua_x, ua_y, ua_w, ua_h = self._usable_area(output)
        for win in desktop.windows:
            if win.closed:
                continue
            if win == focused:
                win.proxy.show()
                if win.node:
                    win.node.set_position(ua_x, ua_y)
                    win.node.place_top()
                self._set_borders(win, True)
            else:
                win.proxy.hide()

    def _layout_split(self, desktop: Desktop, output: OutputState, focused: Optional[WindowState]):
        """2-split layout: left and right halves, top of each stack visible."""
        ua_x, ua_y, ua_w, ua_h = self._usable_area(output)
        left_visible = self._visible_top(desktop.left_stack)

        # Left stack — always positioned at left edge
        for i, win in enumerate(desktop.left_stack):
            if win.closed:
                continue
            if i == 0:
                win.proxy.show()
                if win.node:
                    win.node.set_position(ua_x, ua_y)
                self._set_borders(win, win == focused)
            else:
                win.proxy.hide()

        # Right stack — right-aligned to the right edge of usable area
        right_visible = self._visible_top(desktop.right_stack)
        if right_visible and right_visible.width > 0:
            right_x = ua_x + ua_w - right_visible.width
        elif left_visible and left_visible.width > 0:
            right_x = ua_x + left_visible.width
        else:
            right_x = ua_x + ua_w // 2
        for i, win in enumerate(desktop.right_stack):
            if win.closed:
                continue
            if i == 0:
                win.proxy.show()
                if win.node:
                    win.node.set_position(right_x, ua_y)
                self._set_borders(win, win == focused)
            else:
                win.proxy.hide()

        # Z-order: ensure visible windows are on top
        if desktop.left_stack and desktop.left_stack[0].node:
            desktop.left_stack[0].node.place_top()
        if desktop.right_stack and desktop.right_stack[0].node:
            desktop.right_stack[0].node.place_top()

    def _layout_floating(self, output: OutputState, focused: Optional[WindowState]):
        """Layout floating overlay windows."""
        for i, win in enumerate(self.floating_stack):
            if win.closed:
                continue
            win.proxy.show()
            if win.node:
                win.node.set_position(win.pos_x, win.pos_y)
                win.node.place_top()
            self._set_borders(win, win == focused)

    @staticmethod
    def _visible_top(stack: list) -> Optional[WindowState]:
        """Return the first non-closed window in a stack, or None."""
        for win in stack:
            if not win.closed:
                return win
        return None

    def _set_borders(self, win: WindowState, is_focused: bool):
        """Set border styling for a window."""
        if self.config.border_width <= 0:
            return
        if is_focused:
            win.proxy.set_borders(
                EDGE_ALL, self.config.border_width,
                BORDER_FOCUSED_R, BORDER_FOCUSED_G, BORDER_FOCUSED_B, BORDER_FOCUSED_A
            )
        else:
            win.proxy.set_borders(
                EDGE_ALL, self.config.border_width,
                BORDER_UNFOCUSED_R, BORDER_UNFOCUSED_G, BORDER_UNFOCUSED_B, BORDER_UNFOCUSED_A
            )

    # -------------------------------------------------------------------
    # Interactive move/resize
    # -------------------------------------------------------------------
    def _start_interactive_move(self, seat: SeatState, win: WindowState):
        """Start an interactive pointer move operation."""
        if seat.op_active:
            return
        seat.op_active = True
        seat.op_window = win
        seat.op_mode = "move"
        seat.op_dx = 0
        seat.op_dy = 0
        seat.op_released = False
        win.move_start_x = win.pos_x
        win.move_start_y = win.pos_y
        seat.proxy.op_start_pointer()

    def _start_interactive_resize(self, seat: SeatState, win: WindowState):
        """Start an interactive pointer resize operation."""
        if seat.op_active:
            return
        seat.op_active = True
        seat.op_window = win
        seat.op_mode = "resize"
        seat.op_dx = 0
        seat.op_dy = 0
        seat.op_released = False
        win.move_start_x = win.width
        win.move_start_y = win.height
        seat.proxy.op_start_pointer()

    def _handle_interactive_op(self, seat: SeatState):
        """Handle ongoing interactive operation during manage sequence."""
        win = seat.op_window
        if win is None or win.closed:
            seat.op_active = False
            seat.proxy.op_end()
            return

        if seat.op_mode == "move":
            win.pos_x = win.move_start_x + seat.op_dx
            win.pos_y = win.move_start_y + seat.op_dy
        elif seat.op_mode == "resize":
            new_w = max(100, win.move_start_x + seat.op_dx)
            new_h = max(100, win.move_start_y + seat.op_dy)
            win.proxy.propose_dimensions(new_w, new_h)

        if seat.op_released:
            seat.op_active = False
            seat.proxy.op_end()
            seat.op_window = None

    # -------------------------------------------------------------------
    # Keybinding setup
    # -------------------------------------------------------------------
    def setup_keybindings(self):
        """Register all keybindings with the compositor."""
        if not self.seats:
            logger.warning("No seats available for keybindings")
            return

        seat = self.seats[0]

        # Helper to bind a key
        def bind_key(keysym, modifiers, callback):
            binding = self.xkb_bindings_proxy.get_xkb_binding(seat.proxy, keysym, modifiers)
            def _on_pressed(p, cb=callback, ks=keysym):
                logger.debug("KEY PRESSED: keysym=0x%x", ks)
                cb()
            binding.dispatcher["pressed"] = _on_pressed
            binding.dispatcher["released"] = lambda p: None
            binding.dispatcher["stop_repeat"] = lambda p: None
            self.key_bindings[id(binding)] = (binding, callback)
            self.pending_bindings_to_enable.append(binding)

        def bind_pointer(button, modifiers, press_cb, release_cb=None):
            binding = seat.proxy.get_pointer_binding(button, modifiers)
            binding.dispatcher["pressed"] = lambda p: press_cb()
            binding.dispatcher["released"] = lambda p: (release_cb() if release_cb else None)
            self.pointer_bindings[id(binding)] = (binding, press_cb, release_cb)
            self.pending_bindings_to_enable.append(binding)

        # --- Desktop management ---
        bind_key(XKB_KEY_1, MOD_SUPER, lambda: self._action_switch_desktop(1))
        bind_key(XKB_KEY_2, MOD_SUPER, lambda: self._action_switch_desktop(2))
        bind_key(XKB_KEY_3, MOD_SUPER, lambda: self._action_switch_desktop(3))
        bind_key(XKB_KEY_4, MOD_SUPER, lambda: self._action_switch_desktop(4))

        bind_key(XKB_KEY_1, MOD_SUPER | MOD_SHIFT, lambda: self._action_move_to_desktop(1))
        bind_key(XKB_KEY_2, MOD_SUPER | MOD_SHIFT, lambda: self._action_move_to_desktop(2))
        bind_key(XKB_KEY_3, MOD_SUPER | MOD_SHIFT, lambda: self._action_move_to_desktop(3))
        bind_key(XKB_KEY_4, MOD_SUPER | MOD_SHIFT, lambda: self._action_move_to_desktop(4))

        # Toggle floating overlay
        bind_key(XKB_KEY_space, MOD_SUPER, lambda: self._action_toggle_floating())

        # Move window to floating
        bind_key(XKB_KEY_space, MOD_SUPER | MOD_SHIFT, lambda: self._action_move_to_floating())

        # --- Layout control ---
        bind_key(XKB_KEY_f, MOD_SUPER, lambda: self._action_set_layout(LayoutMode.FULLSCREEN))
        bind_key(XKB_KEY_m, MOD_SUPER, lambda: self._action_set_layout(LayoutMode.MAX))
        bind_key(XKB_KEY_s, MOD_SUPER, lambda: self._action_set_layout(LayoutMode.SPLIT))

        # --- Window navigation ---
        bind_key(XKB_KEY_j, MOD_SUPER, lambda: self._action_cycle_next())
        bind_key(XKB_KEY_k, MOD_SUPER, lambda: self._action_cycle_prev())

        # 2-split: move focus to other side
        bind_key(XKB_KEY_Tab, MOD_SUPER, lambda: self._action_focus_other_side())

        # 2-split: cycle window on current side
        bind_key(XKB_KEY_n, MOD_SUPER, lambda: self._action_cycle_side())

        # --- Window manipulation ---
        # 2-split: move window to other side
        bind_key(XKB_KEY_o, MOD_SUPER, lambda: self._action_move_to_other_side())
        bind_key(XKB_KEY_Tab, MOD_SUPER | MOD_SHIFT, lambda: self._action_move_to_other_side())

        # 2-split: move window up/down in stack
        bind_key(XKB_KEY_k, MOD_SUPER | MOD_SHIFT, lambda: self._action_move_up_in_stack())
        bind_key(XKB_KEY_j, MOD_SUPER | MOD_SHIFT, lambda: self._action_move_down_in_stack())

        # Close window
        bind_key(XKB_KEY_q, MOD_SUPER, lambda: self._action_close_window())

        # --- General ---
        bind_key(XKB_KEY_Return, MOD_SUPER, lambda: self._action_spawn(self.config.terminal_cmd))
        bind_key(XKB_KEY_d, MOD_SUPER, lambda: self._action_spawn(self.config.launcher_cmd))
        bind_key(XKB_KEY_p, MOD_SUPER, lambda: self._action_spawn(self.config.launcher_cmd))

        # Restart WM (hot reload)
        bind_key(XKB_KEY_r, MOD_SUPER | MOD_SHIFT, lambda: self._action_restart_wm())

        # Screenshots: Super+G = region to clipboard, Super+Shift+G = region to file,
        #              Print = full screen to clipboard
        bind_key(XKB_KEY_g, MOD_SUPER, lambda: self._action_screenshot_region())
        bind_key(XKB_KEY_g, MOD_SUPER | MOD_SHIFT, lambda: self._action_screenshot_region_file())
        bind_key(XKB_KEY_Print, 0, lambda: self._action_screenshot_full())

        # --- Pointer bindings for interactive move/resize ---
        bind_pointer(BTN_LEFT, MOD_SUPER, lambda: self._action_pointer_move())
        bind_pointer(BTN_RIGHT, MOD_SUPER, lambda: self._action_pointer_resize())

        # Request a manage sequence to enable bindings
        self.wm_proxy.manage_dirty()

        logger.info("Keybindings registered")

    # -------------------------------------------------------------------
    # Keybinding actions
    # -------------------------------------------------------------------
    def _action_switch_desktop(self, desktop_id: int):
        self._switch_desktop(desktop_id)
        self.wm_proxy.manage_dirty()

    def _action_move_to_desktop(self, desktop_id: int):
        focused = self._get_focused_window()
        if focused:
            self._move_window_to_desktop(focused, desktop_id)
        self.wm_proxy.manage_dirty()

    def _action_toggle_floating(self):
        self.floating_active = not self.floating_active
        self.needs_layout = True
        self.wm_proxy.manage_dirty()
        logger.info("Floating overlay %s", "activated" if self.floating_active else "deactivated")

    def _action_move_to_floating(self):
        focused = self._get_focused_window()
        if focused:
            self._move_window_to_desktop(focused, 0)
        self.wm_proxy.manage_dirty()

    def _action_set_layout(self, mode: LayoutMode):
        self._set_layout_mode(mode)
        self.wm_proxy.manage_dirty()

    def _action_cycle_next(self):
        if self.floating_active and self.floating_stack:
            # Rotate floating stack
            if len(self.floating_stack) > 1:
                self.floating_stack.append(self.floating_stack.pop(0))
            self.wm_proxy.manage_dirty()
            return

        desktop = self.current_desktop
        if desktop.layout == LayoutMode.SPLIT:
            self._action_cycle_side()
            return

        if desktop.windows:
            desktop.focused_index = (desktop.focused_index + 1) % len(desktop.windows)
        self.wm_proxy.manage_dirty()

    def _action_cycle_prev(self):
        if self.floating_active and self.floating_stack:
            if len(self.floating_stack) > 1:
                self.floating_stack.insert(0, self.floating_stack.pop())
            self.wm_proxy.manage_dirty()
            return

        desktop = self.current_desktop
        if desktop.layout == LayoutMode.SPLIT:
            # Cycle in reverse on current side
            stack = desktop.left_stack if desktop.focused_side == Side.LEFT else desktop.right_stack
            if len(stack) > 1:
                stack.insert(0, stack.pop())
            self.wm_proxy.manage_dirty()
            return

        if desktop.windows:
            desktop.focused_index = (desktop.focused_index - 1) % len(desktop.windows)
        self.wm_proxy.manage_dirty()

    def _action_focus_other_side(self):
        desktop = self.current_desktop
        if desktop.layout != LayoutMode.SPLIT:
            return
        if desktop.focused_side == Side.LEFT:
            desktop.focused_side = Side.RIGHT
        else:
            desktop.focused_side = Side.LEFT
        self.wm_proxy.manage_dirty()

    def _action_cycle_side(self):
        desktop = self.current_desktop
        if desktop.layout != LayoutMode.SPLIT:
            return
        stack = desktop.left_stack if desktop.focused_side == Side.LEFT else desktop.right_stack
        if len(stack) > 1:
            stack.append(stack.pop(0))
        self.wm_proxy.manage_dirty()

    def _action_move_to_other_side(self):
        desktop = self.current_desktop
        if desktop.layout != LayoutMode.SPLIT:
            return
        focused = desktop.get_focused_window()
        if focused is None:
            return
        if focused.side == Side.LEFT:
            if focused in desktop.left_stack:
                desktop.left_stack.remove(focused)
            focused.side = Side.RIGHT
            desktop.right_stack.insert(0, focused)
            desktop.focused_side = Side.RIGHT
        else:
            if focused in desktop.right_stack:
                desktop.right_stack.remove(focused)
            focused.side = Side.LEFT
            desktop.left_stack.insert(0, focused)
            desktop.focused_side = Side.LEFT
        self.wm_proxy.manage_dirty()

    def _action_move_up_in_stack(self):
        desktop = self.current_desktop
        if desktop.layout != LayoutMode.SPLIT:
            return
        stack = desktop.left_stack if desktop.focused_side == Side.LEFT else desktop.right_stack
        focused = desktop.get_focused_window()
        if focused is None or focused not in stack:
            return
        idx = stack.index(focused)
        if idx > 0:
            stack[idx], stack[idx - 1] = stack[idx - 1], stack[idx]
        self.wm_proxy.manage_dirty()

    def _action_move_down_in_stack(self):
        desktop = self.current_desktop
        if desktop.layout != LayoutMode.SPLIT:
            return
        stack = desktop.left_stack if desktop.focused_side == Side.LEFT else desktop.right_stack
        focused = desktop.get_focused_window()
        if focused is None or focused not in stack:
            return
        idx = stack.index(focused)
        if idx < len(stack) - 1:
            stack[idx], stack[idx + 1] = stack[idx + 1], stack[idx]
        self.wm_proxy.manage_dirty()

    def _action_close_window(self):
        focused = self._get_focused_window()
        if focused and not focused.closed:
            focused.proxy.close()

    def _action_spawn(self, cmd: str):
        try:
            subprocess.Popen(
                cmd, shell=True,
                stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                start_new_session=True
            )
            logger.info("Spawned: %s", cmd)
        except Exception as e:
            logger.error("Failed to spawn %s: %s", cmd, e)

    def _action_screenshot_region(self):
        """Region select → clipboard."""
        subprocess.Popen("grim -g \"$(slurp)\" - | wl-copy -t image/png",
                         shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        logger.info("Screenshot: region → clipboard")

    def _action_screenshot_region_file(self):
        """Region select → file."""
        import time
        os.makedirs(os.path.expanduser("~/Pictures"), exist_ok=True)
        path = os.path.expanduser(f"~/Pictures/screenshot-{int(time.time())}.png")
        subprocess.Popen(f'grim -g "$(slurp)" {path}',
                         shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        logger.info("Screenshot: region → %s", path)

    def _action_screenshot_full(self):
        """Full screen → clipboard."""
        subprocess.Popen("grim - | wl-copy -t image/png",
                         shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        logger.info("Screenshot: full → clipboard")

    def _action_restart_wm(self):
        """Hot-reload: exit with code 42 so the wrapper script restarts us."""
        logger.info("Hot-reloading WM (exit 42)...")
        self._restart_requested = True
        self.running = False

    def _action_pointer_move(self):
        if not self.seats:
            return
        seat = self.seats[0]
        win = seat.pointer_entered_window
        if win and win.desktop_id == 0:  # Only for floating windows
            self._start_interactive_move(seat, win)

    def _action_pointer_resize(self):
        if not self.seats:
            return
        seat = self.seats[0]
        win = seat.pointer_entered_window
        if win and win.desktop_id == 0:  # Only for floating windows
            self._start_interactive_resize(seat, win)

    # -------------------------------------------------------------------
    # Helpers
    # -------------------------------------------------------------------
    def _find_seat(self, seat_proxy) -> Optional[SeatState]:
        for s in self.seats:
            if s.proxy == seat_proxy:
                return s
        return None

    def _apply_xkb_keymap(self):
        """Apply XKB keymap via river-xkb-config-v1 protocol at runtime."""
        if self.xkb_config_proxy is None:
            if self.config.xkb_layout or self.config.xkb_model or \
               self.config.xkb_variant or self.config.xkb_options:
                logger.warning("river_xkb_config_v1 not available; cannot apply XKB keymap")
            return

        if not any((self.config.xkb_layout, self.config.xkb_model,
                     self.config.xkb_variant, self.config.xkb_options)):
            return

        # Build xkbcli command
        cmd = ["xkbcli", "compile-keymap"]
        if self.config.xkb_layout:
            cmd += ["--layout", self.config.xkb_layout]
        if self.config.xkb_model:
            cmd += ["--model", self.config.xkb_model]
        if self.config.xkb_variant:
            cmd += ["--variant", self.config.xkb_variant]
        if self.config.xkb_options:
            cmd += ["--options", self.config.xkb_options]

        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)
            if result.returncode != 0:
                logger.error("xkbcli compile-keymap failed: %s", result.stderr.strip())
                return
            keymap_text = result.stdout
        except FileNotFoundError:
            logger.error("xkbcli not found; cannot compile XKB keymap")
            return
        except subprocess.TimeoutExpired:
            logger.error("xkbcli compile-keymap timed out")
            return

        # Write keymap to a memfd for the compositor to mmap
        keymap_bytes = keymap_text.encode("utf-8")
        fd = os.memfd_create("xkb-keymap")
        os.write(fd, keymap_bytes)
        os.lseek(fd, 0, os.SEEK_SET)

        # Create the keymap object (format 1 = XKB_KEYMAP_FORMAT_TEXT_V1)
        keymap_proxy = self.xkb_config_proxy.create_keymap(fd, 1)
        os.close(fd)

        def _on_keymap_success(proxy):
            self.xkb_keymap_obj = proxy
            logger.info("Applied XKB keymap (layout=%s model=%s variant=%s options=%s)",
                        self.config.xkb_layout or "(default)",
                        self.config.xkb_model or "(default)",
                        self.config.xkb_variant or "(default)",
                        self.config.xkb_options or "(default)")
            # Apply to any keyboards we already know about
            for kb in self.xkb_keyboards:
                kb.set_keymap(self.xkb_keymap_obj)

        def _on_keymap_failure(proxy, error_msg):
            logger.error("XKB keymap creation failed: %s", error_msg)

        keymap_proxy.dispatcher["success"] = _on_keymap_success
        keymap_proxy.dispatcher["failure"] = _on_keymap_failure

    def _on_xkb_keyboard(self, xkb_config_proxy, keyboard_proxy):
        """Handle new xkb keyboard from river_xkb_config_v1."""
        self.xkb_keyboards.append(keyboard_proxy)

        def _on_keyboard_removed(proxy):
            if proxy in self.xkb_keyboards:
                self.xkb_keyboards.remove(proxy)
            logger.info("XKB keyboard removed")

        keyboard_proxy.dispatcher["removed"] = _on_keyboard_removed
        keyboard_proxy.dispatcher["input_device"] = lambda p, dev: None
        keyboard_proxy.dispatcher["layout"] = lambda p, idx, name: None
        keyboard_proxy.dispatcher["capslock_enabled"] = lambda p: None
        keyboard_proxy.dispatcher["capslock_disabled"] = lambda p: None
        keyboard_proxy.dispatcher["numlock_enabled"] = lambda p: None
        keyboard_proxy.dispatcher["numlock_disabled"] = lambda p: None

        # If keymap already created, apply it to this keyboard
        if self.xkb_keymap_obj is not None:
            keyboard_proxy.set_keymap(self.xkb_keymap_obj)
            logger.info("Applied XKB keymap to new keyboard")
        else:
            logger.debug("XKB keyboard appeared (keymap not yet ready)")

    # -------------------------------------------------------------------
    # Main loop
    # -------------------------------------------------------------------
    def run(self):
        """Main event loop."""
        self.connect()

        # Do an initial roundtrip to get outputs and seats
        self.display.roundtrip()

        # Apply XKB keymap via river-xkb-config-v1 protocol
        self._apply_xkb_keymap()
        self.display.roundtrip()  # process keymap success + apply to keyboards

        # Setup keybindings
        self.setup_keybindings()

        # Flush to send all requests
        self.display.flush()

        logger.info("Entering main event loop")

        while self.running:
            try:
                ret = self.display.dispatch(block=True)
                if ret < 0:
                    logger.error("display.dispatch returned %d, connection lost", ret)
                    break
                self.display.flush()
            except KeyboardInterrupt:
                logger.info("Interrupted, shutting down")
                break
            except Exception as e:
                logger.error("Error in event loop: %s", e, exc_info=True)
                continue

        logger.error("Event loop exited, self.running=%s", self.running)
        self.shutdown()

    def shutdown(self):
        """Clean shutdown."""
        logger.info("Shutting down wm2")
        if self.wm_proxy:
            try:
                self.wm_proxy.stop()
            except Exception:
                pass
        if self.display:
            try:
                self.display.disconnect()
            except Exception:
                pass


def main():
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(asctime)s [%(name)s] %(levelname)s: %(message)s",
        datefmt="%H:%M:%S",
    )

    config = Config.load()
    wm = RiverWM(config)

    # Handle SIGTERM gracefully
    def sigterm_handler(signum, frame):
        wm.running = False
    signal.signal(signal.SIGTERM, sigterm_handler)

    wm.run()
    if getattr(wm, '_restart_requested', False):
        sys.exit(42)
    sys.exit(1)


if __name__ == "__main__":
    main()
